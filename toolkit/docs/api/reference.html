<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Reference &#8212; Roc Toolkit 0.3.0</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/nature.css?v=601dbdee" />
    <link rel="stylesheet" type="text/css" href="../_static/roc.css?v=37117d08" />
    <script src="../_static/documentation_options.js?v=e259d695"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/analytics.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Examples" href="examples.html" />
    <link rel="prev" title="API" href="../api.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="examples.html" title="Examples"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../api.html" title="API"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Roc Toolkit 0.3.0</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../api.html" accesskey="U">API</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Reference</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="reference">
<h1>Reference<a class="headerlink" href="#reference" title="Link to this heading">¶</a></h1>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>There is no compatibility promise until 1.0.0 is released. Small breaking changes are possible.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Alphabetical index is <a class="reference internal" href="../genindex.html"><span class="std std-ref">available here</span></a>.</p>
</div>
<nav class="contents local" id="index">
<p class="topic-title">Index:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#roc-context" id="id1">roc_context</a></p></li>
<li><p><a class="reference internal" href="#roc-sender" id="id2">roc_sender</a></p></li>
<li><p><a class="reference internal" href="#roc-receiver" id="id3">roc_receiver</a></p></li>
<li><p><a class="reference internal" href="#roc-sender-encoder" id="id4">roc_sender_encoder</a></p></li>
<li><p><a class="reference internal" href="#roc-receiver-decoder" id="id5">roc_receiver_decoder</a></p></li>
<li><p><a class="reference internal" href="#roc-frame" id="id6">roc_frame</a></p></li>
<li><p><a class="reference internal" href="#roc-packet" id="id7">roc_packet</a></p></li>
<li><p><a class="reference internal" href="#roc-endpoint" id="id8">roc_endpoint</a></p></li>
<li><p><a class="reference internal" href="#roc-config" id="id9">roc_config</a></p></li>
<li><p><a class="reference internal" href="#roc-metrics" id="id10">roc_metrics</a></p></li>
<li><p><a class="reference internal" href="#roc-log" id="id11">roc_log</a></p></li>
<li><p><a class="reference internal" href="#roc-version" id="id12">roc_version</a></p></li>
</ul>
</nav>
<section id="roc-context">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">roc_context</a><a class="headerlink" href="#roc-context" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;roc/context.h&gt;</span>
</pre></div>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.roc_context">
<span class="target" id="context_8h_1a854f5a77756c8c473fef82d13b1e470f"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_context" title="roc_context"><span class="n"><span class="pre">roc_context</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_context</span></span></span><a class="headerlink" href="#c.roc_context" title="Link to this definition">¶</a><br /></dt>
<dd><p>Shared context. </p>
<p>Context contains memory pools and network worker threads, shared among objects attached to the context. It is allowed both to create a separate context for every object, or to create a single context shared between multiple objects.</p>
<p><strong>Life cycle</strong></p>
<p>A context is created using <a class="reference internal" href="#context_8h_1afbda7a8d83a1b5b0b3a22b9ca86a25ad"><span class="std std-ref">roc_context_open()</span></a> and destroyed using <a class="reference internal" href="#context_8h_1a0463ad06b4887e968a1a65220300a00b"><span class="std std-ref">roc_context_close()</span></a>. Objects can be attached and detached to an opened context at any moment from any thread. However, the user should ensure that the context is not closed until there are no objects attached to the context.</p>
<p><strong>Thread safety</strong></p>
<p>Can be used concurrently</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sender_8h_1ad2370a2cbe2174fd33a630b08acbc783"><span class="std std-ref">roc_sender</span></a>, <a class="reference internal" href="#receiver_8h_1ade93cec525bde9a255df34d85eb70280"><span class="std std-ref">roc_receiver</span></a></p>
</div>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_context_open">
<span class="target" id="context_8h_1afbda7a8d83a1b5b0b3a22b9ca86a25ad"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_context_open</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_context_config" title="roc_context_config"><span class="n"><span class="pre">roc_context_config</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">config</span></span>, <a class="reference internal" href="#c.roc_context" title="roc_context"><span class="n"><span class="pre">roc_context</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_context_open" title="Link to this definition">¶</a><br /></dt>
<dd><p>Open a new context. </p>
<p>Allocates and initializes a new context. May start some background threads. Overrides the provided <code class="docutils literal notranslate"><span class="pre">result</span></code> pointer with the newly created context.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">config</span></code> should point to an initialized config</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">result</span></code> should point to an unitialized roc_context pointer</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the context was successfully created</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value if there are not enough resources</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>passes the ownership of <code class="docutils literal notranslate"><span class="pre">result</span></code> to the user; the user is responsible to call <a class="reference internal" href="#context_8h_1a0463ad06b4887e968a1a65220300a00b"><span class="std std-ref">roc_context_close()</span></a> to free it </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_context_register_encoding">
<span class="target" id="context_8h_1a43ff1ec42c996b34af90cf8a9a8b900c"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_context_register_encoding</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_context" title="roc_context"><span class="n"><span class="pre">roc_context</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">context</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">encoding_id</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_media_encoding" title="roc_media_encoding"><span class="n"><span class="pre">roc_media_encoding</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">encoding</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_context_register_encoding" title="Link to this definition">¶</a><br /></dt>
<dd><p>Register custom encoding. </p>
<p>Registers <code class="docutils literal notranslate"><span class="pre">encoding</span></code> with given <code class="docutils literal notranslate"><span class="pre">encoding_id</span></code>. Registered encodings complement built-in encodings defined by roc_packet_encoding enum. Whenever you need to specify packet encoding, you can use both built-in and registered encodings.</p>
<p>On sender, you should register custom encoding and set to <code class="docutils literal notranslate"><span class="pre">packet_encoding</span></code> field of <code class="docutils literal notranslate"><a class="reference internal" href="#structroc__sender__config"><span class="std std-ref"><span class="pre">roc_sender_config</span></span></a></code>, if you need to force specific encoding of packets, but built-in set of encodings is not enough.</p>
<p>On receiver, you should register custom encoding with same id and specification, if you did so on sender, and you’re not using any signaling protocol (like RTSP) that is capable of automatic exchange of encoding information.</p>
<p>In case of RTP, encoding id is mapped directly to payload type field (PT).</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">context</span></code> should point to an opened context</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">encoding_id</span></code> should be encoding identifier in range [1; 127]</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">encoding</span></code> should point to valid encoding specification</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if encoding was successfully registered</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value if encoding with given identifier already exists</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">encoding</span></code>; copies its contents to internal encodings table </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_context_close">
<span class="target" id="context_8h_1a0463ad06b4887e968a1a65220300a00b"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_context_close</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_context" title="roc_context"><span class="n"><span class="pre">roc_context</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">context</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_context_close" title="Link to this definition">¶</a><br /></dt>
<dd><p>Close the context. </p>
<p>Stops any started background threads, deinitializes and deallocates the context. The user should ensure that nobody uses the context during and after this call.</p>
<p>If this function fails, the context is kept opened.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">context</span></code> should point to an opened context</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the context was successfully closed</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value if there are objects attached to the context</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>ends the user ownership of <code class="docutils literal notranslate"><span class="pre">context</span></code>; it can’t be used anymore after the function returns </p></li>
</ul>
</p>
</dd></dl>

</section>
<section id="roc-sender">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">roc_sender</a><a class="headerlink" href="#roc-sender" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;roc/sender.h&gt;</span>
</pre></div>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.roc_sender">
<span class="target" id="sender_8h_1ad2370a2cbe2174fd33a630b08acbc783"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_sender" title="roc_sender"><span class="n"><span class="pre">roc_sender</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender</span></span></span><a class="headerlink" href="#c.roc_sender" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sender node. </p>
<p>Sender gets an audio stream from the user, encodes it into network packets, and transmits them to a remote receiver.</p>
<p><strong>Context</strong></p>
<p>Sender is automatically attached to a context when opened and detached from it when closed. The user should not close the context until the sender is closed.</p>
<p>Sender work consists of two parts: stream encoding and packet transmission. The encoding part is performed in the sender itself, and the transmission part is performed in the context network worker threads.</p>
<p><strong>Life cycle</strong></p>
<p><ul class="simple">
<li><p>A sender is created using <a class="reference internal" href="#sender_8h_1ae84d98a80e2e18358af0c1afea52e431"><span class="std std-ref">roc_sender_open()</span></a>.</p></li>
<li><p>Optionally, the sender parameters may be fine-tuned using <a class="reference internal" href="#sender_8h_1a792e3cbdef71690c431cc3fabf786623"><span class="std std-ref">roc_sender_configure()</span></a>.</p></li>
<li><p>The sender either binds local endpoints using roc_sender_bind(), allowing receivers connecting to them, or itself connects to remote receiver endpoints using <a class="reference internal" href="#sender_8h_1af92877ec6972fbee1d9a6449f2923cf1"><span class="std std-ref">roc_sender_connect()</span></a>. What approach to use is up to the user.</p></li>
<li><p>The audio stream is iteratively written to the sender using <a class="reference internal" href="#sender_8h_1aac8af571b6c95be970d86887b7d36357"><span class="std std-ref">roc_sender_write()</span></a>. The sender encodes the stream into packets and send to connected receiver(s).</p></li>
<li><p>The sender is destroyed using <a class="reference internal" href="#sender_8h_1a4b0d784d2d2989ef84baa7b672782fdb"><span class="std std-ref">roc_sender_close()</span></a>.</p></li>
</ul>
</p>
<p><strong>Slots, interfaces, and endpoints</strong></p>
<p>Sender has one or multiple <strong>slots</strong>, which may be independently bound or connected. Slots may be used to connect sender to multiple receivers. Slots are numbered from zero and are created automatically. In simple cases just use <code class="docutils literal notranslate"><span class="pre">ROC_SLOT_DEFAULT</span></code>.</p>
<p>Each slot has its own set of <em>interfaces</em>, one per each type defined in roc_interface. The interface defines the type of the communication with the remote node and the set of the protocols supported by it.</p>
<p>Supported actions with the interface:</p>
<p><ul class="simple">
<li><p>Call roc_sender_bind() to bind the interface to a local <a class="reference internal" href="#endpoint_8h_1a062c7188419cb9fb84473cab4f98d253"><span class="std std-ref">roc_endpoint</span></a>. In this case the sender accepts connections from receivers and sends media stream to all connected receivers.</p></li>
<li><p>Call <a class="reference internal" href="#sender_8h_1af92877ec6972fbee1d9a6449f2923cf1"><span class="std std-ref">roc_sender_connect()</span></a> to connect the interface to a remote <a class="reference internal" href="#endpoint_8h_1a062c7188419cb9fb84473cab4f98d253"><span class="std std-ref">roc_endpoint</span></a>. In this case the sender initiates connection to the receiver and starts sending media stream to it.</p></li>
</ul>
</p>
<p>Supported interface configurations:</p>
<p><ul class="simple">
<li><p>Connect <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada6cc2c48ad02f079083752725486e16c4"><span class="std std-ref">ROC_INTERFACE_CONSOLIDATED</span></a> to a remote endpoint (e.g. be an RTSP client).</p></li>
<li><p>Bind <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada6cc2c48ad02f079083752725486e16c4"><span class="std std-ref">ROC_INTERFACE_CONSOLIDATED</span></a> to a local endpoint (e.g. be an RTSP server).</p></li>
<li><p>Connect <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada3475b769d44ad2d7a2fc6a77ea4b56f4"><span class="std std-ref">ROC_INTERFACE_AUDIO_SOURCE</span></a>, <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3adad3274771f2022355b75bdb0ccd3e9477"><span class="std std-ref">ROC_INTERFACE_AUDIO_REPAIR</span></a> (optionally, for FEC), and <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada434747ad3b00f5ab653adaeb2ccd6a08"><span class="std std-ref">ROC_INTERFACE_AUDIO_CONTROL</span></a> (optionally, for control messages) to remote endpoints (e.g. be an RTP/FECFRAME/RTCP sender).</p></li>
</ul>
</p>
<p>Slots can be removed using <a class="reference internal" href="#sender_8h_1aaf1fe84af04f783fdf83994492d3af56"><span class="std std-ref">roc_sender_unlink()</span></a>. Removing a slot also removes all its interfaces and terminates all associated connections.</p>
<p>Slots can be added and removed at any time on fly and from any thread. It is safe to do it from another thread concurrently with writing frames. Operations with slots won’t block concurrent writes.</p>
<p><strong>FEC scheme</strong></p>
<p>If <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada6cc2c48ad02f079083752725486e16c4"><span class="std std-ref">ROC_INTERFACE_CONSOLIDATED</span></a> is used, it automatically creates all necessary transport interfaces and the user should not bother about them.</p>
<p>Otherwise, the user should manually configure <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada3475b769d44ad2d7a2fc6a77ea4b56f4"><span class="std std-ref">ROC_INTERFACE_AUDIO_SOURCE</span></a> and <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3adad3274771f2022355b75bdb0ccd3e9477"><span class="std std-ref">ROC_INTERFACE_AUDIO_REPAIR</span></a> interfaces:</p>
<p><ul class="simple">
<li><p>If FEC is disabled (<a class="reference internal" href="#config_8h_1afa58151e9df856eec5851b59815db865a514d4be99dce993ea190b680ec5b9c6b"><span class="std std-ref">ROC_FEC_ENCODING_DISABLE</span></a>), only <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada3475b769d44ad2d7a2fc6a77ea4b56f4"><span class="std std-ref">ROC_INTERFACE_AUDIO_SOURCE</span></a> should be configured. It will be used to transmit audio packets.</p></li>
<li><p>If FEC is enabled, both <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada3475b769d44ad2d7a2fc6a77ea4b56f4"><span class="std std-ref">ROC_INTERFACE_AUDIO_SOURCE</span></a> and <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3adad3274771f2022355b75bdb0ccd3e9477"><span class="std std-ref">ROC_INTERFACE_AUDIO_REPAIR</span></a> interfaces should be configured. The second interface will be used to transmit redundant repair data.</p></li>
</ul>
</p>
<p>The protocols for the two interfaces should correspond to each other and to the FEC scheme. For example, if <a class="reference internal" href="#config_8h_1afa58151e9df856eec5851b59815db865ab65967c71eebe075df069897f6857d34"><span class="std std-ref">ROC_FEC_ENCODING_RS8M</span></a> is used, the protocols should be <a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a15335419340ecc17b7391770c1d5a4e1"><span class="std std-ref">ROC_PROTO_RTP_RS8M_SOURCE</span></a> and <a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a633ff1a3684f0aac55f9d9026986d182"><span class="std std-ref">ROC_PROTO_RS8M_REPAIR</span></a>.</p>
<p><strong>Sample rate</strong></p>
<p>If the sample rate of the user frames and the sample rate of the network packets are different, the sender employs resampler to convert one rate to another.</p>
<p>Resampling is a quite time-consuming operation. The user can choose between several resampler profiles providing different compromises between CPU consumption and quality.</p>
<p><strong>Clock source</strong></p>
<p>Sender should encode samples at a constant rate that is configured when the sender is created. There are two ways to accomplish this:</p>
<p><ul>
<li><p>If the user enabled internal clock (<a class="reference internal" href="#config_8h_1add917f6cbdc964eb7a42f47769bc2407acf671d4c072d601ff4dfa293e6434767"><span class="std std-ref">ROC_CLOCK_SOURCE_INTERNAL</span></a>), the sender employs a CPU timer to block writes until it’s time to encode the next bunch of samples according to the configured sample rate.</p>
<p>This mode is useful when the user gets samples from a non-realtime source, e.g. from an audio file.</p>
</li>
<li><p>If the user enabled external clock (<a class="reference internal" href="#config_8h_1add917f6cbdc964eb7a42f47769bc2407ac4b026fb3476ce4fed4f946c3fc9fd7a"><span class="std std-ref">ROC_CLOCK_SOURCE_EXTERNAL</span></a>), the samples written to the sender are encoded and sent immediately, and hence the user is responsible to call write operation according to the sample rate.</p>
<p>This mode is useful when the user gets samples from a realtime source with its own clock, e.g. from an audio device. Internal clock should not be used in this case because the audio device and the CPU might have slightly different clocks, and the difference will eventually lead to an underrun or an overrun.</p>
</li>
</ul>
</p>
<p><strong>Thread safety</strong></p>
<p>Can be used concurrently. </p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_sender_open">
<span class="target" id="sender_8h_1ae84d98a80e2e18358af0c1afea52e431"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender_open</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_context" title="roc_context"><span class="n"><span class="pre">roc_context</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">context</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_sender_config" title="roc_sender_config"><span class="n"><span class="pre">roc_sender_config</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">config</span></span>, <a class="reference internal" href="#c.roc_sender" title="roc_sender"><span class="n"><span class="pre">roc_sender</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_sender_open" title="Link to this definition">¶</a><br /></dt>
<dd><p>Open a new sender. </p>
<p>Allocates and initializes a new sender, and attaches it to the context.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">context</span></code> should point to an opened context</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">config</span></code> should point to an initialized config</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">result</span></code> should point to an unitialized roc_sender pointer</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the sender was successfully created</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value on resource allocation failure</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">config</span></code>; it may be safely deallocated after the function returns</p></li>
<li><p>passes the ownership of <code class="docutils literal notranslate"><span class="pre">result</span></code> to the user; the user is responsible to call <a class="reference internal" href="#sender_8h_1a4b0d784d2d2989ef84baa7b672782fdb"><span class="std std-ref">roc_sender_close()</span></a> to free it</p></li>
<li><p>attaches created sender to <code class="docutils literal notranslate"><span class="pre">context</span></code>; the user should not close context before closing sender </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_sender_configure">
<span class="target" id="sender_8h_1a792e3cbdef71690c431cc3fabf786623"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender_configure</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_sender" title="roc_sender"><span class="n"><span class="pre">roc_sender</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sender</span></span>, <a class="reference internal" href="#c.roc_slot" title="roc_slot"><span class="n"><span class="pre">roc_slot</span></span></a><span class="w"> </span><span class="n"><span class="pre">slot</span></span>, <a class="reference internal" href="#c.roc_interface" title="roc_interface"><span class="n"><span class="pre">roc_interface</span></span></a><span class="w"> </span><span class="n"><span class="pre">iface</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">roc_interface_config</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">config</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_sender_configure" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set sender interface configuration. </p>
<p>Updates configuration of specified interface of specified slot. If called, the call should be done before calling roc_sender_bind() or <a class="reference internal" href="#sender_8h_1af92877ec6972fbee1d9a6449f2923cf1"><span class="std std-ref">roc_sender_connect()</span></a> for the same interface.</p>
<p>Automatically initializes slot with given index if it’s used first time.</p>
<p>If an error happens during configure, the whole slot is disabled and marked broken. The slot index remains reserved. The user is responsible for removing the slot using <a class="reference internal" href="#sender_8h_1aaf1fe84af04f783fdf83994492d3af56"><span class="std std-ref">roc_sender_unlink()</span></a>, after which slot index can be reused.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sender</span></code> should point to an opened sender</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">slot</span></code> specifies the sender slot</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iface</span></code> specifies the sender interface</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">config</span></code> should be point to an initialized config</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if config was successfully updated</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value if slot is already bound or connected</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">config</span></code>; it may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_sender_connect">
<span class="target" id="sender_8h_1af92877ec6972fbee1d9a6449f2923cf1"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender_connect</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_sender" title="roc_sender"><span class="n"><span class="pre">roc_sender</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sender</span></span>, <a class="reference internal" href="#c.roc_slot" title="roc_slot"><span class="n"><span class="pre">roc_slot</span></span></a><span class="w"> </span><span class="n"><span class="pre">slot</span></span>, <a class="reference internal" href="#c.roc_interface" title="roc_interface"><span class="n"><span class="pre">roc_interface</span></span></a><span class="w"> </span><span class="n"><span class="pre">iface</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_endpoint" title="roc_endpoint"><span class="n"><span class="pre">roc_endpoint</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endpoint</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_sender_connect" title="Link to this definition">¶</a><br /></dt>
<dd><p>Connect the sender interface to a remote receiver endpoint. </p>
<p>Checks that the endpoint is valid and supported by the interface, allocates a new outgoing port, and connects it to the remote endpoint.</p>
<p>Each slot’s interface can be bound or connected only once. May be called multiple times for different slots or interfaces.</p>
<p>Automatically initializes slot with given index if it’s used first time.</p>
<p>If an error happens during connect, the whole slot is disabled and marked broken. The slot index remains reserved. The user is responsible for removing the slot using <a class="reference internal" href="#sender_8h_1aaf1fe84af04f783fdf83994492d3af56"><span class="std std-ref">roc_sender_unlink()</span></a>, after which slot index can be reused.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sender</span></code> should point to an opened sender</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">slot</span></code> specifies the sender slot</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iface</span></code> specifies the sender interface</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">endpoint</span></code> specifies the receiver endpoint</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the sender was successfully connected</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value on resource allocation failure</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">endpoint</span></code>; it may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_sender_query">
<span class="target" id="sender_8h_1a4d7e3e7fe5732e0ad43205d88b5fffbb"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender_query</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_sender" title="roc_sender"><span class="n"><span class="pre">roc_sender</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sender</span></span>, <a class="reference internal" href="#c.roc_slot" title="roc_slot"><span class="n"><span class="pre">roc_slot</span></span></a><span class="w"> </span><span class="n"><span class="pre">slot</span></span>, <a class="reference internal" href="#c.roc_sender_metrics" title="roc_sender_metrics"><span class="n"><span class="pre">roc_sender_metrics</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">metrics</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_sender_query" title="Link to this definition">¶</a><br /></dt>
<dd><p>Query sender slot metrics. </p>
<p>Reads sender slot metrics into provided struct.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sender</span></code> should point to an opened sender</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">slot</span></code> specifies the sender slot</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">metrics</span></code> specifies struct where to write metrics</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the slot was successfully removed</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value if the slot does not exist</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">metrics</span></code>; it may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_sender_unlink">
<span class="target" id="sender_8h_1aaf1fe84af04f783fdf83994492d3af56"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender_unlink</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_sender" title="roc_sender"><span class="n"><span class="pre">roc_sender</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sender</span></span>, <a class="reference internal" href="#c.roc_slot" title="roc_slot"><span class="n"><span class="pre">roc_slot</span></span></a><span class="w"> </span><span class="n"><span class="pre">slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_sender_unlink" title="Link to this definition">¶</a><br /></dt>
<dd><p>Delete sender slot. </p>
<p>Disconnects, unbinds, and removes all slot interfaces and removes the slot. All associated connections to remote nodes are properly terminated.</p>
<p>After unlinking the slot, it can be re-created again by re-using slot index.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sender</span></code> should point to an opened sender</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">slot</span></code> specifies the sender slot</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the slot was successfully removed</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value if the slot does not exist </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_sender_write">
<span class="target" id="sender_8h_1aac8af571b6c95be970d86887b7d36357"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender_write</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_sender" title="roc_sender"><span class="n"><span class="pre">roc_sender</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sender</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_frame" title="roc_frame"><span class="n"><span class="pre">roc_frame</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">frame</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_sender_write" title="Link to this definition">¶</a><br /></dt>
<dd><p>Encode samples to packets and transmit them to the receiver. </p>
<p>Encodes samples to packets and enqueues them for transmission by the network worker thread of the context.</p>
<p>If <a class="reference internal" href="#config_8h_1add917f6cbdc964eb7a42f47769bc2407acf671d4c072d601ff4dfa293e6434767"><span class="std std-ref">ROC_CLOCK_SOURCE_INTERNAL</span></a> is used, the function blocks until it’s time to transmit the samples according to the configured sample rate. The function returns after encoding and enqueuing the packets, without waiting when the packets are actually transmitted.</p>
<p>Until the sender is connected to at least one receiver, the stream is just dropped. If the sender is connected to multiple receivers, the stream is duplicated to each of them.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sender</span></code> should point to an opened sender</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">frame</span></code> should point to an initialized frame; it should contain pointer to a buffer and it’s size; the buffer is fully copied into the sender</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if all samples were successfully encoded and enqueued</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value on resource allocation failure</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">frame</span></code>; it may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_sender_close">
<span class="target" id="sender_8h_1a4b0d784d2d2989ef84baa7b672782fdb"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender_close</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_sender" title="roc_sender"><span class="n"><span class="pre">roc_sender</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sender</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_sender_close" title="Link to this definition">¶</a><br /></dt>
<dd><p>Close the sender. </p>
<p>Deinitializes and deallocates the sender, and detaches it from the context. The user should ensure that nobody uses the sender during and after this call. If this function fails, the sender is kept opened and attached to the context.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sender</span></code> should point to an opened sender</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the sender was successfully closed</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>ends the user ownership of <code class="docutils literal notranslate"><span class="pre">sender</span></code>; it can’t be used anymore after the function returns </p></li>
</ul>
</p>
</dd></dl>

</section>
<section id="roc-receiver">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">roc_receiver</a><a class="headerlink" href="#roc-receiver" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;roc/receiver.h&gt;</span>
</pre></div>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.roc_receiver">
<span class="target" id="receiver_8h_1ade93cec525bde9a255df34d85eb70280"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_receiver" title="roc_receiver"><span class="n"><span class="pre">roc_receiver</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver</span></span></span><a class="headerlink" href="#c.roc_receiver" title="Link to this definition">¶</a><br /></dt>
<dd><p>Receiver node. </p>
<p>Receiver gets the network packets from multiple senders, decodes audio streams from them, mixes multiple streams into a single stream, and returns it to the user.</p>
<p><strong>Context</strong></p>
<p>Receiver is automatically attached to a context when opened and detached from it when closed. The user should not close the context until the receiver is closed.</p>
<p>Receiver work consists of two parts: packet reception and stream decoding. The decoding part is performed in the receiver itself, and the reception part is performed in the context network worker threads.</p>
<p><strong>Life cycle</strong></p>
<p><ul class="simple">
<li><p>A receiver is created using <a class="reference internal" href="#receiver_8h_1a782bca44acb6424559028ac6d6a32912"><span class="std std-ref">roc_receiver_open()</span></a>.</p></li>
<li><p>Optionally, the receiver parameters may be fine-tuned using <a class="reference internal" href="#receiver_8h_1a2962928ce89e515c0967abeeb1698108"><span class="std std-ref">roc_receiver_configure()</span></a>.</p></li>
<li><p>The receiver either binds local endpoints using <a class="reference internal" href="#receiver_8h_1a59c04df83c44c2600144201c91fea718"><span class="std std-ref">roc_receiver_bind()</span></a>, allowing senders connecting to them, or itself connects to remote sender endpoints using roc_receiver_connect(). What approach to use is up to the user.</p></li>
<li><p>The audio stream is iteratively read from the receiver using <a class="reference internal" href="#receiver_8h_1a704c14cc2755d0864fe25d0fb9b58c2b"><span class="std std-ref">roc_receiver_read()</span></a>. Receiver returns the mixed stream from all connected senders.</p></li>
<li><p>The receiver is destroyed using <a class="reference internal" href="#receiver_8h_1a0ef487dc6079e23b000b2da906f2fb77"><span class="std std-ref">roc_receiver_close()</span></a>.</p></li>
</ul>
</p>
<p><strong>Slots, interfaces, and endpoints</strong></p>
<p>Receiver has one or multiple <strong>slots</strong>, which may be independently bound or connected. Slots may be used to bind receiver to multiple addresses. Slots are numbered from zero and are created automatically. In simple cases just use <code class="docutils literal notranslate"><span class="pre">ROC_SLOT_DEFAULT</span></code>.</p>
<p>Each slot has its own set of <em>interfaces</em>, one per each type defined in roc_interface. The interface defines the type of the communication with the remote node and the set of the protocols supported by it.</p>
<p>Supported actions with the interface:</p>
<p><ul class="simple">
<li><p>Call <a class="reference internal" href="#receiver_8h_1a59c04df83c44c2600144201c91fea718"><span class="std std-ref">roc_receiver_bind()</span></a> to bind the interface to a local <a class="reference internal" href="#endpoint_8h_1a062c7188419cb9fb84473cab4f98d253"><span class="std std-ref">roc_endpoint</span></a>. In this case the receiver accepts connections from senders mixes their streams into the single output stream.</p></li>
<li><p>Call roc_receiver_connect() to connect the interface to a remote <a class="reference internal" href="#endpoint_8h_1a062c7188419cb9fb84473cab4f98d253"><span class="std std-ref">roc_endpoint</span></a>. In this case the receiver initiates connection to the sender and requests it to start sending media stream to the receiver.</p></li>
</ul>
</p>
<p>Supported interface configurations:</p>
<p><ul class="simple">
<li><p>Bind <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada6cc2c48ad02f079083752725486e16c4"><span class="std std-ref">ROC_INTERFACE_CONSOLIDATED</span></a> to a local endpoint (e.g. be an RTSP server).</p></li>
<li><p>Connect <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada6cc2c48ad02f079083752725486e16c4"><span class="std std-ref">ROC_INTERFACE_CONSOLIDATED</span></a> to a remote endpoint (e.g. be an RTSP client).</p></li>
<li><p>Bind <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada3475b769d44ad2d7a2fc6a77ea4b56f4"><span class="std std-ref">ROC_INTERFACE_AUDIO_SOURCE</span></a>, <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3adad3274771f2022355b75bdb0ccd3e9477"><span class="std std-ref">ROC_INTERFACE_AUDIO_REPAIR</span></a> (optionally, for FEC), and <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada434747ad3b00f5ab653adaeb2ccd6a08"><span class="std std-ref">ROC_INTERFACE_AUDIO_CONTROL</span></a> (optionally, for control messages) to local endpoints (e.g. be an RTP/FECFRAME/RTCP receiver).</p></li>
</ul>
</p>
<p>Slots can be removed using <a class="reference internal" href="#receiver_8h_1a819af9a237ff418dcd711f93c3bfd0f8"><span class="std std-ref">roc_receiver_unlink()</span></a>. Removing a slot also removes all its interfaces and terminates all associated connections.</p>
<p>Slots can be added and removed at any time on fly and from any thread. It is safe to do it from another thread concurrently with reading frames. Operations with slots won’t block concurrent reads.</p>
<p><strong>FEC scheme</strong></p>
<p>If <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada6cc2c48ad02f079083752725486e16c4"><span class="std std-ref">ROC_INTERFACE_CONSOLIDATED</span></a> is used, it automatically creates all necessary transport interfaces and the user should not bother about them.</p>
<p>Otherwise, the user should manually configure <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada3475b769d44ad2d7a2fc6a77ea4b56f4"><span class="std std-ref">ROC_INTERFACE_AUDIO_SOURCE</span></a> and <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3adad3274771f2022355b75bdb0ccd3e9477"><span class="std std-ref">ROC_INTERFACE_AUDIO_REPAIR</span></a> interfaces:</p>
<p><ul class="simple">
<li><p>If FEC is disabled (<a class="reference internal" href="#config_8h_1afa58151e9df856eec5851b59815db865a514d4be99dce993ea190b680ec5b9c6b"><span class="std std-ref">ROC_FEC_ENCODING_DISABLE</span></a>), only <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada3475b769d44ad2d7a2fc6a77ea4b56f4"><span class="std std-ref">ROC_INTERFACE_AUDIO_SOURCE</span></a> should be configured. It will be used to transmit audio packets.</p></li>
<li><p>If FEC is enabled, both <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada3475b769d44ad2d7a2fc6a77ea4b56f4"><span class="std std-ref">ROC_INTERFACE_AUDIO_SOURCE</span></a> and <a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3adad3274771f2022355b75bdb0ccd3e9477"><span class="std std-ref">ROC_INTERFACE_AUDIO_REPAIR</span></a> interfaces should be configured. The second interface will be used to transmit redundant repair data.</p></li>
</ul>
</p>
<p>The protocols for the two interfaces should correspond to each other and to the FEC scheme. For example, if <a class="reference internal" href="#config_8h_1afa58151e9df856eec5851b59815db865ab65967c71eebe075df069897f6857d34"><span class="std std-ref">ROC_FEC_ENCODING_RS8M</span></a> is used, the protocols should be <a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a15335419340ecc17b7391770c1d5a4e1"><span class="std std-ref">ROC_PROTO_RTP_RS8M_SOURCE</span></a> and <a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a633ff1a3684f0aac55f9d9026986d182"><span class="std std-ref">ROC_PROTO_RS8M_REPAIR</span></a>.</p>
<p><strong>Sessions</strong></p>
<p>Receiver creates a session object for every sender connected to it. Sessions can appear and disappear at any time. Multiple sessions can be active at the same time.</p>
<p>A session is identified by the sender address. A session may contain multiple packet streams sent to different receiver ports. If the sender employs FEC, the session will contain source and repair packet streams. Otherwise, the session will contain a single source packet stream.</p>
<p>A session is created automatically on the reception of the first packet from a new address and destroyed when there are no packets during a timeout. A session is also destroyed on other events like a large latency underrun or overrun or broken playback, but if the sender continues to send packets, it will be created again shortly.</p>
<p><strong>Mixing</strong></p>
<p>Receiver mixes audio streams from all currently active sessions into a single output stream.</p>
<p>The output stream continues no matter how much active sessions there are at the moment. In particular, if there are no sessions, the receiver produces a stream with all zeros.</p>
<p>Sessions can be added and removed from the output stream at any time, probably in the middle of a frame.</p>
<p><strong>Sample rate</strong></p>
<p>Every session may have a different sample rate. And even if nominally all of them are of the same rate, device frequencies usually differ by a few tens of Hertz.</p>
<p>Receiver compensates these differences by adjusting the rate of every session stream to the rate of the receiver output stream using a per-session resampler. The frequencies factor between the sender and the receiver clocks is calculated dynamically for every session based on the session incoming packet queue size.</p>
<p>Resampling is a quite time-consuming operation. The user can choose between several resampler profiles providing different compromises between CPU consumption and quality.</p>
<p><strong>Clock source</strong></p>
<p>Receiver should decode samples at a constant rate that is configured when the receiver is created. There are two ways to accomplish this:</p>
<p><ul>
<li><p>If the user enabled internal clock (<a class="reference internal" href="#config_8h_1add917f6cbdc964eb7a42f47769bc2407acf671d4c072d601ff4dfa293e6434767"><span class="std std-ref">ROC_CLOCK_SOURCE_INTERNAL</span></a>), the receiver employs a CPU timer to block reads until it’s time to decode the next bunch of samples according to the configured sample rate.</p>
<p>This mode is useful when the user passes samples to a non-realtime destination, e.g. to an audio file.</p>
</li>
<li><p>If the user enabled external clock (<a class="reference internal" href="#config_8h_1add917f6cbdc964eb7a42f47769bc2407ac4b026fb3476ce4fed4f946c3fc9fd7a"><span class="std std-ref">ROC_CLOCK_SOURCE_EXTERNAL</span></a>), the samples read from the receiver are decoded immediately and hence the user is responsible to call read operation according to the sample rate.</p>
<p>This mode is useful when the user passes samples to a realtime destination with its own clock, e.g. to an audio device. Internal clock should not be used in this case because the audio device and the CPU might have slightly different clocks, and the difference will eventually lead to an underrun or an overrun.</p>
</li>
</ul>
</p>
<p><strong>Thread safety</strong></p>
<p>Can be used concurrently. </p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_receiver_open">
<span class="target" id="receiver_8h_1a782bca44acb6424559028ac6d6a32912"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver_open</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_context" title="roc_context"><span class="n"><span class="pre">roc_context</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">context</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_receiver_config" title="roc_receiver_config"><span class="n"><span class="pre">roc_receiver_config</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">config</span></span>, <a class="reference internal" href="#c.roc_receiver" title="roc_receiver"><span class="n"><span class="pre">roc_receiver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_receiver_open" title="Link to this definition">¶</a><br /></dt>
<dd><p>Open a new receiver. </p>
<p>Allocates and initializes a new receiver, and attaches it to the context.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">context</span></code> should point to an opened context</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">config</span></code> should point to an initialized config</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">result</span></code> should point to an unitialized roc_receiver pointer</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the receiver was successfully created</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value on resource allocation failure</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">config</span></code>; it may be safely deallocated after the function returns</p></li>
<li><p>passes the ownership of <code class="docutils literal notranslate"><span class="pre">result</span></code> to the user; the user is responsible to call <a class="reference internal" href="#receiver_8h_1a0ef487dc6079e23b000b2da906f2fb77"><span class="std std-ref">roc_receiver_close()</span></a> to free it</p></li>
<li><p>attaches created receiver to <code class="docutils literal notranslate"><span class="pre">context</span></code>; the user should not close context before closing receiver </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_receiver_configure">
<span class="target" id="receiver_8h_1a2962928ce89e515c0967abeeb1698108"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver_configure</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_receiver" title="roc_receiver"><span class="n"><span class="pre">roc_receiver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">receiver</span></span>, <a class="reference internal" href="#c.roc_slot" title="roc_slot"><span class="n"><span class="pre">roc_slot</span></span></a><span class="w"> </span><span class="n"><span class="pre">slot</span></span>, <a class="reference internal" href="#c.roc_interface" title="roc_interface"><span class="n"><span class="pre">roc_interface</span></span></a><span class="w"> </span><span class="n"><span class="pre">iface</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">roc_interface_config</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">config</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_receiver_configure" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set receiver interface configuration. </p>
<p>Updates configuration of specified interface of specified slot. If called, the call should be done before calling <a class="reference internal" href="#receiver_8h_1a59c04df83c44c2600144201c91fea718"><span class="std std-ref">roc_receiver_bind()</span></a> or roc_receiver_connect() for the same interface.</p>
<p>Automatically initializes slot with given index if it’s used first time.</p>
<p>If an error happens during configure, the whole slot is disabled and marked broken. The slot index remains reserved. The user is responsible for removing the slot using <a class="reference internal" href="#receiver_8h_1a819af9a237ff418dcd711f93c3bfd0f8"><span class="std std-ref">roc_receiver_unlink()</span></a>, after which slot index can be reused.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">receiver</span></code> should point to an opened receiver</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">slot</span></code> specifies the receiver slot</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iface</span></code> specifies the receiver interface</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">config</span></code> should be point to an initialized config</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if config was successfully updated</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value if slot is already bound or connected</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">config</span></code>; it may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_receiver_bind">
<span class="target" id="receiver_8h_1a59c04df83c44c2600144201c91fea718"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver_bind</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_receiver" title="roc_receiver"><span class="n"><span class="pre">roc_receiver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">receiver</span></span>, <a class="reference internal" href="#c.roc_slot" title="roc_slot"><span class="n"><span class="pre">roc_slot</span></span></a><span class="w"> </span><span class="n"><span class="pre">slot</span></span>, <a class="reference internal" href="#c.roc_interface" title="roc_interface"><span class="n"><span class="pre">roc_interface</span></span></a><span class="w"> </span><span class="n"><span class="pre">iface</span></span>, <a class="reference internal" href="#c.roc_endpoint" title="roc_endpoint"><span class="n"><span class="pre">roc_endpoint</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endpoint</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_receiver_bind" title="Link to this definition">¶</a><br /></dt>
<dd><p>Bind the receiver interface to a local endpoint. </p>
<p>Checks that the endpoint is valid and supported by the interface, allocates a new ingoing port, and binds it to the local endpoint.</p>
<p>Each slot’s interface can be bound or connected only once. May be called multiple times for different slots or interfaces.</p>
<p>Automatically initializes slot with given index if it’s used first time.</p>
<p>If an error happens during bind, the whole slot is disabled and marked broken. The slot index remains reserved. The user is responsible for removing the slot using <a class="reference internal" href="#receiver_8h_1a819af9a237ff418dcd711f93c3bfd0f8"><span class="std std-ref">roc_receiver_unlink()</span></a>, after which slot index can be reused.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">endpoint</span></code> has explicitly set zero port, the receiver is bound to a randomly chosen ephemeral port. If the function succeeds, the actual port to which the receiver was bound is written back to <code class="docutils literal notranslate"><span class="pre">endpoint</span></code>.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">receiver</span></code> should point to an opened receiver</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">slot</span></code> specifies the receiver slot</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iface</span></code> specifies the receiver interface</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">endpoint</span></code> specifies the receiver endpoint</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the receiver was successfully bound to a port</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value if the address can’t be bound</p></li>
<li><p>returns a negative value on resource allocation failure</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">endpoint</span></code>; it may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_receiver_query">
<span class="target" id="receiver_8h_1af1fbbdd3671b2f60a9c9bd1f138eb7c1"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver_query</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_receiver" title="roc_receiver"><span class="n"><span class="pre">roc_receiver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">receiver</span></span>, <a class="reference internal" href="#c.roc_slot" title="roc_slot"><span class="n"><span class="pre">roc_slot</span></span></a><span class="w"> </span><span class="n"><span class="pre">slot</span></span>, <a class="reference internal" href="#c.roc_receiver_metrics" title="roc_receiver_metrics"><span class="n"><span class="pre">roc_receiver_metrics</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">metrics</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_receiver_query" title="Link to this definition">¶</a><br /></dt>
<dd><p>Query receiver slot metrics. </p>
<p>Reads receiver slot metrics into provided struct.</p>
<p>To retrieve per-session metrics, set <code class="docutils literal notranslate"><span class="pre">sessions</span></code> field of <a class="reference internal" href="#structroc__receiver__metrics"><span class="std std-ref">roc_receiver_metrics</span></a> to a buffer of <a class="reference internal" href="#structroc__session__metrics"><span class="std std-ref">roc_session_metrics</span></a> structs, and <code class="docutils literal notranslate"><span class="pre">sessions_size</span></code> to the number of structs in buffer. The function will write session metrcis to the buffer and update <code class="docutils literal notranslate"><span class="pre">sessions_size</span></code> with the actual number of sessions written.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">sessions_size</span></code> is lesser than actual number of sessions, metrics for some sessions will be dropped. <code class="docutils literal notranslate"><span class="pre">num_sessions</span></code> will always contain actual total number.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">sessions</span></code> field is NULL, per-session metrics are not retrieved.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">receiver</span></code> should point to an opened receiver</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">slot</span></code> specifies the receiver slot</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">metrics</span></code> specifies struct where to write metrics</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the slot was successfully removed</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value if the slot does not exist</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">metrics</span></code> or its <code class="docutils literal notranslate"><span class="pre">sessions</span></code> field; they may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_receiver_unlink">
<span class="target" id="receiver_8h_1a819af9a237ff418dcd711f93c3bfd0f8"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver_unlink</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_receiver" title="roc_receiver"><span class="n"><span class="pre">roc_receiver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">receiver</span></span>, <a class="reference internal" href="#c.roc_slot" title="roc_slot"><span class="n"><span class="pre">roc_slot</span></span></a><span class="w"> </span><span class="n"><span class="pre">slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_receiver_unlink" title="Link to this definition">¶</a><br /></dt>
<dd><p>Delete receiver slot. </p>
<p>Disconnects, unbinds, and removes all slot interfaces and removes the slot. All associated connections to remote nodes are properly terminated.</p>
<p>After unlinking the slot, it can be re-created again by re-using slot index.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">receiver</span></code> should point to an opened receiver</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">slot</span></code> specifies the receiver slot</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the slot was successfully removed</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value if the slot does not exist </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_receiver_read">
<span class="target" id="receiver_8h_1a704c14cc2755d0864fe25d0fb9b58c2b"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver_read</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_receiver" title="roc_receiver"><span class="n"><span class="pre">roc_receiver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">receiver</span></span>, <a class="reference internal" href="#c.roc_frame" title="roc_frame"><span class="n"><span class="pre">roc_frame</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">frame</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_receiver_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read samples from the receiver. </p>
<p>Reads retrieved network packets, decodes packets, routes packets to sessions, repairs losses, extracts samples, adjusts sample rate and channel layout, compensates clock drift, mixes samples from all sessions, and finally stores samples into the provided frame.</p>
<p>If <a class="reference internal" href="#config_8h_1add917f6cbdc964eb7a42f47769bc2407acf671d4c072d601ff4dfa293e6434767"><span class="std std-ref">ROC_CLOCK_SOURCE_INTERNAL</span></a> is used, the function blocks until it’s time to decode the samples according to the configured sample rate.</p>
<p>Until the receiver is connected to at least one sender, it produces silence. If the receiver is connected to multiple senders, it mixes their streams into one.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">receiver</span></code> should point to an opened receiver</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">frame</span></code> should point to an initialized frame; it should contain pointer to a buffer and it’s size; the buffer is fully filled with data from receiver</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if all samples were successfully decoded</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value on resource allocation failure</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">frame</span></code>; it may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_receiver_close">
<span class="target" id="receiver_8h_1a0ef487dc6079e23b000b2da906f2fb77"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver_close</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_receiver" title="roc_receiver"><span class="n"><span class="pre">roc_receiver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">receiver</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_receiver_close" title="Link to this definition">¶</a><br /></dt>
<dd><p>Close the receiver. </p>
<p>Deinitializes and deallocates the receiver, and detaches it from the context. The user should ensure that nobody uses the receiver during and after this call. If this function fails, the receiver is kept opened and attached to the context.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">receiver</span></code> should point to an opened receiver</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the receiver was successfully closed</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>ends the user ownership of <code class="docutils literal notranslate"><span class="pre">receiver</span></code>; it can’t be used anymore after the function returns </p></li>
</ul>
</p>
</dd></dl>

</section>
<section id="roc-sender-encoder">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">roc_sender_encoder</a><a class="headerlink" href="#roc-sender-encoder" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;roc/sender_encoder.h&gt;</span>
</pre></div>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.roc_sender_encoder">
<span class="target" id="sender__encoder_8h_1a05edb5a223d677bf049fd26aace81652"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_sender_encoder" title="roc_sender_encoder"><span class="n"><span class="pre">roc_sender_encoder</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender_encoder</span></span></span><a class="headerlink" href="#c.roc_sender_encoder" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sender encoder node. </p>
<p>Sender encoder gets an audio stream from the user, encodes it into network packets, and provides encoded packets back to the user.</p>
<p>Sender encoder is a simplified networkless version of <a class="reference internal" href="#sender_8h_1ad2370a2cbe2174fd33a630b08acbc783"><span class="std std-ref">roc_sender</span></a>. It implements the same pipeline, but instead of sending packets, it just provides them to the user. The user is responsible for delivering these packets to receiver.</p>
<p>For detailed description of sender pipeline, see documentation for <a class="reference internal" href="#sender_8h_1ad2370a2cbe2174fd33a630b08acbc783"><span class="std std-ref">roc_sender</span></a>.</p>
<p><strong>Life cycle</strong></p>
<p><ul class="simple">
<li><p>Encoder is created using <a class="reference internal" href="#sender__encoder_8h_1ab11faa6c7fe09588ef2ec103b3ecce41"><span class="std std-ref">roc_sender_encoder_open()</span></a>.</p></li>
<li><p>The user activates one or more interfaces by invoking <a class="reference internal" href="#sender__encoder_8h_1a30b235deb812468a8e8fe28a566d3e48"><span class="std std-ref">roc_sender_encoder_activate()</span></a>. This tells encoder what types of streams to produces and what protocols to use for them (e.g. only audio packets or also redundancy packets).</p></li>
<li><p>The audio stream is iteratively pushed to the encoder using <a class="reference internal" href="#sender__encoder_8h_1a0c7329c6ff390297ca593d7c76067eec"><span class="std std-ref">roc_sender_encoder_push()</span></a>. The sender encodes the stream into packets and accumulates them in internal queue.</p></li>
<li><p>The packet stream is iteratively popped from the encoder internal queue using <a class="reference internal" href="#sender__encoder_8h_1aa796e2d1696a32474bee0ffcfcc545a1"><span class="std std-ref">roc_sender_encoder_pop()</span></a>. User should retrieve all available packets from all activated interfaces every time after pushing a frame.</p></li>
<li><p>User is responsible for delivering packets to <a class="reference internal" href="#receiver__decoder_8h_1adff9e8bdbc403d22a942beb037bb636d"><span class="std std-ref">roc_receiver_decoder</span></a> and pushing them to appropriate interfaces of decoder.</p></li>
<li><p>The sender is eventually destroyed using <a class="reference internal" href="#sender__encoder_8h_1a37e25835629e798ba3f2c05ded9b624d"><span class="std std-ref">roc_sender_encoder_close()</span></a>.</p></li>
</ul>
</p>
<p><strong>Interfaces and protocols</strong></p>
<p>Sender encoder may have one or several <em>interfaces</em>, as defined in roc_interface. The interface defines the type of the communication with the remote node and the set of the protocols supported by it.</p>
<p>Each interface has its own packet queue. When a frame is pushed to the encoder, it may produce multiple packets for each interface queue. The user then should pop packets from each interface that was activated.</p>
<p><strong>Thread safety</strong></p>
<p>Can be used concurrently. </p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_sender_encoder_open">
<span class="target" id="sender__encoder_8h_1ab11faa6c7fe09588ef2ec103b3ecce41"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender_encoder_open</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_context" title="roc_context"><span class="n"><span class="pre">roc_context</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">context</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_sender_config" title="roc_sender_config"><span class="n"><span class="pre">roc_sender_config</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">config</span></span>, <a class="reference internal" href="#c.roc_sender_encoder" title="roc_sender_encoder"><span class="n"><span class="pre">roc_sender_encoder</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_sender_encoder_open" title="Link to this definition">¶</a><br /></dt>
<dd><p>Open a new encoder. </p>
<p>Allocates and initializes a new encoder, and attaches it to the context.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">context</span></code> should point to an opened context</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">config</span></code> should point to an initialized config</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">result</span></code> should point to an unitialized roc_sender_encoder pointer</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the encoder was successfully created</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value on resource allocation failure</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">config</span></code>; it may be safely deallocated after the function returns</p></li>
<li><p>passes the ownership of <code class="docutils literal notranslate"><span class="pre">result</span></code> to the user; the user is responsible to call <a class="reference internal" href="#sender__encoder_8h_1a37e25835629e798ba3f2c05ded9b624d"><span class="std std-ref">roc_sender_encoder_close()</span></a> to free it</p></li>
<li><p>attaches created encoder to <code class="docutils literal notranslate"><span class="pre">context</span></code>; the user should not close context before closing encoder </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_sender_encoder_activate">
<span class="target" id="sender__encoder_8h_1a30b235deb812468a8e8fe28a566d3e48"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender_encoder_activate</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_sender_encoder" title="roc_sender_encoder"><span class="n"><span class="pre">roc_sender_encoder</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">encoder</span></span>, <a class="reference internal" href="#c.roc_interface" title="roc_interface"><span class="n"><span class="pre">roc_interface</span></span></a><span class="w"> </span><span class="n"><span class="pre">iface</span></span>, <a class="reference internal" href="#c.roc_protocol" title="roc_protocol"><span class="n"><span class="pre">roc_protocol</span></span></a><span class="w"> </span><span class="n"><span class="pre">proto</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_sender_encoder_activate" title="Link to this definition">¶</a><br /></dt>
<dd><p>Activate encoder interface. </p>
<p>Checks that the protocol is valid and supported by the interface, and initializes given interface with given protocol.</p>
<p>The user should invoke <a class="reference internal" href="#sender__encoder_8h_1aa796e2d1696a32474bee0ffcfcc545a1"><span class="std std-ref">roc_sender_encoder_pop()</span></a> for all activated interfaces and deliver packets to appropriate interfaces of <a class="reference internal" href="#receiver__decoder_8h_1adff9e8bdbc403d22a942beb037bb636d"><span class="std std-ref">roc_receiver_decoder</span></a>.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">encoder</span></code> should point to an opened encoder</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iface</span></code> specifies the encoder interface</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">proto</span></code> specifies the encoder protocol</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if interface was successfully activated</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value on resource allocation failure </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_sender_encoder_query">
<span class="target" id="sender__encoder_8h_1a63ecad6bb0d415f968a89fd67cc29b8b"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender_encoder_query</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_sender_encoder" title="roc_sender_encoder"><span class="n"><span class="pre">roc_sender_encoder</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">encoder</span></span>, <a class="reference internal" href="#c.roc_sender_metrics" title="roc_sender_metrics"><span class="n"><span class="pre">roc_sender_metrics</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">metrics</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_sender_encoder_query" title="Link to this definition">¶</a><br /></dt>
<dd><p>Query encoder metrics. </p>
<p>Reads encoder metrics into provided struct.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">encoder</span></code> should point to an opened encoder</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">metrics</span></code> specifies struct where to write metrics</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the slot was successfully removed</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value if the slot does not exist</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">metrics</span></code>; it may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_sender_encoder_push">
<span class="target" id="sender__encoder_8h_1a0c7329c6ff390297ca593d7c76067eec"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender_encoder_push</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_sender_encoder" title="roc_sender_encoder"><span class="n"><span class="pre">roc_sender_encoder</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">encoder</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_frame" title="roc_frame"><span class="n"><span class="pre">roc_frame</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">frame</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_sender_encoder_push" title="Link to this definition">¶</a><br /></dt>
<dd><p>Write frame to encoder. </p>
<p>Encodes samples to into network packets and enqueues them to internal queues of activated interfaces.</p>
<p>If <a class="reference internal" href="#config_8h_1add917f6cbdc964eb7a42f47769bc2407acf671d4c072d601ff4dfa293e6434767"><span class="std std-ref">ROC_CLOCK_SOURCE_INTERNAL</span></a> is used, the function blocks until it’s time to encode the samples according to the configured sample rate.</p>
<p>Until at least one interface is activated, the stream is just dropped.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">encoder</span></code> should point to an opened encoder</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">frame</span></code> should point to an initialized frame; it should contain pointer to a buffer and it’s size; the buffer is fully copied into encoder</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if all samples were successfully encoded and enqueued</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value on resource allocation failure</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">frame</span></code>; it may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_sender_encoder_pop">
<span class="target" id="sender__encoder_8h_1aa796e2d1696a32474bee0ffcfcc545a1"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender_encoder_pop</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_sender_encoder" title="roc_sender_encoder"><span class="n"><span class="pre">roc_sender_encoder</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">encoder</span></span>, <a class="reference internal" href="#c.roc_interface" title="roc_interface"><span class="n"><span class="pre">roc_interface</span></span></a><span class="w"> </span><span class="n"><span class="pre">iface</span></span>, <a class="reference internal" href="#c.roc_packet" title="roc_packet"><span class="n"><span class="pre">roc_packet</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">packet</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_sender_encoder_pop" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read packet from encoder. </p>
<p>Removes encoded packet from interface queue and returns it to the user.</p>
<p>Packets are added to the queue from <a class="reference internal" href="#sender__encoder_8h_1a0c7329c6ff390297ca593d7c76067eec"><span class="std std-ref">roc_sender_encoder_push()</span></a>. Each push may produce multiple packets, so the user should iteratively pop packets until error. This should be repeated for all activated interfaces.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">encoder</span></code> should point to an opened encoder</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">packet</span></code> should point to an initialized packet; it should contain pointer to a buffer and it’s size; packet bytes are copied to user’s buffer and the size field is updated with the actual packet size</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if a packet was successfully copied from encoder</p></li>
<li><p>returns a negative value if there are no more packets for this interface</p></li>
<li><p>returns a negative value if the interface is not activated</p></li>
<li><p>returns a negative value if the buffer size of the provided packet is too small</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value on resource allocation failure</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">packet</span></code>; it may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_sender_encoder_close">
<span class="target" id="sender__encoder_8h_1a37e25835629e798ba3f2c05ded9b624d"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender_encoder_close</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_sender_encoder" title="roc_sender_encoder"><span class="n"><span class="pre">roc_sender_encoder</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">encoder</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_sender_encoder_close" title="Link to this definition">¶</a><br /></dt>
<dd><p>Close encoder. </p>
<p>Deinitializes and deallocates the encoder, and detaches it from the context. The user should ensure that nobody uses the encoder during and after this call. If this function fails, the encoder is kept opened and attached to the context.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">encoder</span></code> should point to an opened encoder</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the encoder was successfully closed</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>ends the user ownership of <code class="docutils literal notranslate"><span class="pre">encoder</span></code>; it can’t be used anymore after the function returns </p></li>
</ul>
</p>
</dd></dl>

</section>
<section id="roc-receiver-decoder">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">roc_receiver_decoder</a><a class="headerlink" href="#roc-receiver-decoder" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;roc/receiver_decoder.h&gt;</span>
</pre></div>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.roc_receiver_decoder">
<span class="target" id="receiver__decoder_8h_1adff9e8bdbc403d22a942beb037bb636d"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_receiver_decoder" title="roc_receiver_decoder"><span class="n"><span class="pre">roc_receiver_decoder</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver_decoder</span></span></span><a class="headerlink" href="#c.roc_receiver_decoder" title="Link to this definition">¶</a><br /></dt>
<dd><p>Receiver decoder node. </p>
<p>Receiver decoder gets an encoded network packets from the user, decodes audio stream from them, and provides it back to the user.</p>
<p>Receiver decoder is a simplified networkless version of <a class="reference internal" href="#receiver_8h_1ade93cec525bde9a255df34d85eb70280"><span class="std std-ref">roc_receiver</span></a>. It implements the same pipeline, but instead of receiving packets, it just gets them from the user. The user is responsible for delivering these packets to receiver.</p>
<p>For detailed description of receiver pipeline, see documentation for <a class="reference internal" href="#receiver_8h_1ade93cec525bde9a255df34d85eb70280"><span class="std std-ref">roc_receiver</span></a>.</p>
<p><strong>Life cycle</strong></p>
<p><ul class="simple">
<li><p>Decoder is created using <a class="reference internal" href="#receiver__decoder_8h_1abf6688d2e0326ed8b293556d37be5460"><span class="std std-ref">roc_receiver_decoder_open()</span></a>.</p></li>
<li><p>The user activates one or more interfaces by invoking <a class="reference internal" href="#receiver__decoder_8h_1afb9be19c2f5c659aa3f84220d47c3917"><span class="std std-ref">roc_receiver_decoder_activate()</span></a>. This tells decoder what types of streams to consume and what protocols to use for them (e.g. only audio packets or also redundancy packets).</p></li>
<li><p>The per-interface streams of encoded packets are iteratively pushed to the decoder using <a class="reference internal" href="#receiver__decoder_8h_1afee1374fd9b3a1714920b3a1fd082fc3"><span class="std std-ref">roc_receiver_decoder_push()</span></a>.</p></li>
<li><p>The audio stream is iteratively popped from the decoder using <a class="reference internal" href="#receiver__decoder_8h_1a0a33a4d33d15bfa081056580c45ce140"><span class="std std-ref">roc_receiver_decoder_pop()</span></a>. User should push all available packets to all interfaces before popping a frame.</p></li>
<li><p>User is responsible for delivering packets from <a class="reference internal" href="#sender__encoder_8h_1a05edb5a223d677bf049fd26aace81652"><span class="std std-ref">roc_sender_encoder</span></a> and pushing them to appropriate interfaces of decoder.</p></li>
<li><p>The receiver is eventually destroyed using <a class="reference internal" href="#receiver__decoder_8h_1a223c5ede1ad93c1926ee2a2067fb77b3"><span class="std std-ref">roc_receiver_decoder_close()</span></a>.</p></li>
</ul>
</p>
<p><strong>Interfaces and protocols</strong></p>
<p>Receiver decoder may have one or several <em>interfaces</em>, as defined in roc_interface. The interface defines the type of the communication with the remote node and the set of the protocols supported by it.</p>
<p>Each interface has its own packet queue. When a packet is pushed to the decoder, it is accumulated in the queue. When a frame is popped from the decoder, it consumes those accumulated packets.</p>
<p><strong>Thread safety</strong></p>
<p>Can be used concurrently. </p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_receiver_decoder_open">
<span class="target" id="receiver__decoder_8h_1abf6688d2e0326ed8b293556d37be5460"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver_decoder_open</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_context" title="roc_context"><span class="n"><span class="pre">roc_context</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">context</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_receiver_config" title="roc_receiver_config"><span class="n"><span class="pre">roc_receiver_config</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">config</span></span>, <a class="reference internal" href="#c.roc_receiver_decoder" title="roc_receiver_decoder"><span class="n"><span class="pre">roc_receiver_decoder</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_receiver_decoder_open" title="Link to this definition">¶</a><br /></dt>
<dd><p>Open a new decoder. </p>
<p>Allocates and initializes a new decoder, and attaches it to the context.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">context</span></code> should point to an opened context</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">config</span></code> should point to an initialized config</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">result</span></code> should point to an unitialized roc_receiver_decoder pointer</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the decoder was successfully created</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value on resource allocation failure</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">config</span></code>; it may be safely deallocated after the function returns</p></li>
<li><p>passes the ownership of <code class="docutils literal notranslate"><span class="pre">result</span></code> to the user; the user is responsible to call <a class="reference internal" href="#receiver__decoder_8h_1a223c5ede1ad93c1926ee2a2067fb77b3"><span class="std std-ref">roc_receiver_decoder_close()</span></a> to free it</p></li>
<li><p>attaches created decoder to <code class="docutils literal notranslate"><span class="pre">context</span></code>; the user should not close context before closing decoder </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_receiver_decoder_activate">
<span class="target" id="receiver__decoder_8h_1afb9be19c2f5c659aa3f84220d47c3917"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver_decoder_activate</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_receiver_decoder" title="roc_receiver_decoder"><span class="n"><span class="pre">roc_receiver_decoder</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">decoder</span></span>, <a class="reference internal" href="#c.roc_interface" title="roc_interface"><span class="n"><span class="pre">roc_interface</span></span></a><span class="w"> </span><span class="n"><span class="pre">iface</span></span>, <a class="reference internal" href="#c.roc_protocol" title="roc_protocol"><span class="n"><span class="pre">roc_protocol</span></span></a><span class="w"> </span><span class="n"><span class="pre">proto</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_receiver_decoder_activate" title="Link to this definition">¶</a><br /></dt>
<dd><p>Activate decoder interface. </p>
<p>Checks that the protocol is valid and supported by the interface, and initializes given interface with given protocol.</p>
<p>The user should invoke <a class="reference internal" href="#receiver__decoder_8h_1afee1374fd9b3a1714920b3a1fd082fc3"><span class="std std-ref">roc_receiver_decoder_push()</span></a> for all activated interfaces and deliver packets from appropriate interfaces of <a class="reference internal" href="#sender__encoder_8h_1a05edb5a223d677bf049fd26aace81652"><span class="std std-ref">roc_sender_encoder</span></a>.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">decoder</span></code> should point to an opened decoder</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iface</span></code> specifies the decoder interface</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">proto</span></code> specifies the decoder protocol</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if interface was successfully activated</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value on resource allocation failure </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_receiver_decoder_query">
<span class="target" id="receiver__decoder_8h_1a85f96b6908d813b20004949a26a80e17"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver_decoder_query</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_receiver_decoder" title="roc_receiver_decoder"><span class="n"><span class="pre">roc_receiver_decoder</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">decoder</span></span>, <a class="reference internal" href="#c.roc_receiver_metrics" title="roc_receiver_metrics"><span class="n"><span class="pre">roc_receiver_metrics</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">metrics</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_receiver_decoder_query" title="Link to this definition">¶</a><br /></dt>
<dd><p>Query decoder metrics. </p>
<p>Reads decoder metrics into provided struct.</p>
<p>To retrieve per-session metrics, set <code class="docutils literal notranslate"><span class="pre">sessions</span></code> field of <a class="reference internal" href="#structroc__receiver__metrics"><span class="std std-ref">roc_receiver_metrics</span></a> to a buffer of <a class="reference internal" href="#structroc__session__metrics"><span class="std std-ref">roc_session_metrics</span></a> structs, and <code class="docutils literal notranslate"><span class="pre">sessions_size</span></code> to the number of structs in buffer. The function will write session metrcis to the buffer and update <code class="docutils literal notranslate"><span class="pre">sessions_size</span></code> with the actual number of sessions written.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">sessions_size</span></code> is lesser than actual number of sessions, metrics for some sessions will be dropped. <code class="docutils literal notranslate"><span class="pre">num_sessions</span></code> will always contain actual total number.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">sessions</span></code> field is NULL, per-session metrics are not retrieved.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">decoder</span></code> should point to an opened decoder</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">metrics</span></code> specifies struct where to write metrics</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the slot was successfully removed</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value if the slot does not exist</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">metrics</span></code> or its <code class="docutils literal notranslate"><span class="pre">sessions</span></code> field; they may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_receiver_decoder_push">
<span class="target" id="receiver__decoder_8h_1afee1374fd9b3a1714920b3a1fd082fc3"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver_decoder_push</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_receiver_decoder" title="roc_receiver_decoder"><span class="n"><span class="pre">roc_receiver_decoder</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">decoder</span></span>, <a class="reference internal" href="#c.roc_interface" title="roc_interface"><span class="n"><span class="pre">roc_interface</span></span></a><span class="w"> </span><span class="n"><span class="pre">iface</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_packet" title="roc_packet"><span class="n"><span class="pre">roc_packet</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">packet</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_receiver_decoder_push" title="Link to this definition">¶</a><br /></dt>
<dd><p>Write packet to decoder. </p>
<p>Add encoded packet to the interface queue.</p>
<p>The user should iteratively push all delivered packets to appropriate interfaces. They will be later consumed by <a class="reference internal" href="#receiver__decoder_8h_1a0a33a4d33d15bfa081056580c45ce140"><span class="std std-ref">roc_receiver_decoder_pop()</span></a>.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">decoder</span></code> should point to an opened decoder</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">packet</span></code> should point to an initialized packet; it should contain pointer to a buffer and it’s size; the buffer is fully copied into decoder</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if a packet was successfully copied to decoder</p></li>
<li><p>returns a negative value if the interface is not activated</p></li>
<li><p>returns a negative value if the buffer size of the provided packet is too large</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value on resource allocation failure</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">packet</span></code>; it may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_receiver_decoder_pop">
<span class="target" id="receiver__decoder_8h_1a0a33a4d33d15bfa081056580c45ce140"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver_decoder_pop</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_receiver_decoder" title="roc_receiver_decoder"><span class="n"><span class="pre">roc_receiver_decoder</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">decoder</span></span>, <a class="reference internal" href="#c.roc_frame" title="roc_frame"><span class="n"><span class="pre">roc_frame</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">frame</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_receiver_decoder_pop" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read samples from decoder. </p>
<p>Reads pushed network packets, decodes packets, repairs losses, extracts samples, adjusts sample rate and channel layout, compensates clock drift, and stores samples into the provided frame.</p>
<p>If <a class="reference internal" href="#config_8h_1add917f6cbdc964eb7a42f47769bc2407acf671d4c072d601ff4dfa293e6434767"><span class="std std-ref">ROC_CLOCK_SOURCE_INTERNAL</span></a> is used, the function blocks until it’s time to decode the samples according to the configured sample rate.</p>
<p>Until at least one interface is activated, decoder produces silence.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">decoder</span></code> should point to an opened decoder</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">frame</span></code> should point to an initialized frame; it should contain pointer to a buffer and it’s size; the buffer is fully filled with data from decoder</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if all samples were successfully decoded</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
<li><p>returns a negative value on resource allocation failure</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">frame</span></code>; it may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_receiver_decoder_close">
<span class="target" id="receiver__decoder_8h_1a223c5ede1ad93c1926ee2a2067fb77b3"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver_decoder_close</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_receiver_decoder" title="roc_receiver_decoder"><span class="n"><span class="pre">roc_receiver_decoder</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">decoder</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_receiver_decoder_close" title="Link to this definition">¶</a><br /></dt>
<dd><p>Close decoder. </p>
<p>Deinitializes and deallocates the decoder, and detaches it from the context. The user should ensure that nobody uses the decoder during and after this call. If this function fails, the decoder is kept opened and attached to the context.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">decoder</span></code> should point to an opened decoder</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if the decoder was successfully closed</p></li>
<li><p>returns a negative value if the arguments are invalid</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>ends the user ownership of <code class="docutils literal notranslate"><span class="pre">decoder</span></code>; it can’t be used anymore after the function returns </p></li>
</ul>
</p>
</dd></dl>

</section>
<section id="roc-frame">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">roc_frame</a><a class="headerlink" href="#roc-frame" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;roc/frame.h&gt;</span>
</pre></div>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.roc_frame">
<span class="target" id="structroc__frame"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_frame</span></span></span><a class="headerlink" href="#c.roc_frame" title="Link to this definition">¶</a><br /></dt>
<dd><p>Audio frame. </p>
<p>Represents a multichannel sequence of audio samples. The user is responsible for allocating and deallocating the frame and the data it is pointing to.</p>
<p><strong>Thread safety</strong></p>
<p>Should not be used concurrently. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.roc_frame.samples">
<span class="target" id="structroc__frame_1a21dcd52504c141419b9ba6ba261f9671"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">samples</span></span></span><a class="headerlink" href="#c.roc_frame.samples" title="Link to this definition">¶</a><br /></dt>
<dd><p>Audio samples. </p>
<p>Sample rate, channel set, and encoding are defined by the sender or receiver parameters. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_frame.samples_size">
<span class="target" id="structroc__frame_1a595b256fa3f6e5127831c9e24f65b337"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">samples_size</span></span></span><a class="headerlink" href="#c.roc_frame.samples_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sample buffer size. </p>
<p>Defines the size of samples buffer in bytes. </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="roc-packet">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">roc_packet</a><a class="headerlink" href="#roc-packet" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;roc/packet.h&gt;</span>
</pre></div>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.roc_packet">
<span class="target" id="structroc__packet"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_packet</span></span></span><a class="headerlink" href="#c.roc_packet" title="Link to this definition">¶</a><br /></dt>
<dd><p>Network packet. </p>
<p>Represents opaque encoded binary packet.</p>
<p><strong>Thread safety</strong></p>
<p>Should not be used concurrently. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.roc_packet.bytes">
<span class="target" id="structroc__packet_1adc71e869e4cd37dafc6e478b4f90c8fc"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">bytes</span></span></span><a class="headerlink" href="#c.roc_packet.bytes" title="Link to this definition">¶</a><br /></dt>
<dd><p>Packet bytes. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_packet.bytes_size">
<span class="target" id="structroc__packet_1a99eb88fb12b2fdaae4292d4cce91fd9c"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bytes_size</span></span></span><a class="headerlink" href="#c.roc_packet.bytes_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>Packet bytes count. </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="roc-endpoint">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">roc_endpoint</a><a class="headerlink" href="#roc-endpoint" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;roc/endpoint.h&gt;</span>
</pre></div>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.roc_endpoint">
<span class="target" id="endpoint_8h_1a062c7188419cb9fb84473cab4f98d253"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_endpoint" title="roc_endpoint"><span class="n"><span class="pre">roc_endpoint</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_endpoint</span></span></span><a class="headerlink" href="#c.roc_endpoint" title="Link to this definition">¶</a><br /></dt>
<dd><p>Network endpoint. </p>
<p>Endpoint is a network entry point of a node. The definition includes the protocol being used, network host and port, and, for some protocols, a resource. All these parts together are unambiguously represented by a URI. The user may set or get the entire URI or its individual parts.</p>
<p><strong>Endpoint URI</strong></p>
<p>Endpoint URI syntax is a subset of the syntax defined in RFC 3986: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span>protocol://host[:port][/path][?query]
</pre></div>
</div>
 Examples:<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rtsp://localhost:123/path?query</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rtp+rs8m://localhost:123</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rtp://127.0.0.1:123</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rtp://[::1]:123</span></code></p></li>
</ul>
</p>
<p>The following protocols (schemes) are supported:<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rtp://</span></code> (<a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516ada758c721fa39b567b0f89e38fa29edb"><span class="std std-ref">ROC_PROTO_RTP</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rtp+rs8m://</span></code> (<a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a15335419340ecc17b7391770c1d5a4e1"><span class="std std-ref">ROC_PROTO_RTP_RS8M_SOURCE</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rs8m://</span></code> (<a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a633ff1a3684f0aac55f9d9026986d182"><span class="std std-ref">ROC_PROTO_RS8M_REPAIR</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rtp+ldpc://</span></code> (<a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a7bee9e5bd2d93c4c5247903173e03ad2"><span class="std std-ref">ROC_PROTO_RTP_LDPC_SOURCE</span></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ldpc://</span></code> (<a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a6fbfad98e2c22513cdb30a0935d7afe7"><span class="std std-ref">ROC_PROTO_LDPC_REPAIR</span></a>)</p></li>
</ul>
</p>
<p>The host field should be either FQDN (domain name), or IPv4 address, or IPv6 address in square brackets.</p>
<p>The port field can be omitted if the protocol defines standard port. Otherwise, the port can not be omitted. For example, RTSP defines standard port, but RTP doesn’t.</p>
<p>The path and query fields are allowed only for protocols that support them. For example, they’re supported by RTSP, but not by RTP.</p>
<p><strong>Field invalidation</strong></p>
<p>If some field is attempted to be set to an invalid value (for example, an invalid port number), this specific field is marked as invalid until it is successfully set to some valid value.</p>
<p>Sender and receiver refuse to bind or connect an endpoint which has invalid fields or doesn’t have some mandatory fields. Hence, it is safe to ignore errors returned by endpoint setters and check only for errors returned by bind and connect operations.</p>
<p><strong>Thread safety</strong></p>
<p>Should not be used concurrently. </p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_endpoint_allocate">
<span class="target" id="endpoint_8h_1ae331fe561d6d34308e71343f56091a0e"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_endpoint_allocate</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_endpoint" title="roc_endpoint"><span class="n"><span class="pre">roc_endpoint</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_endpoint_allocate" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate and initialize endpoint. </p>
<p>All components of the newly created endpoint are empty.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">result</span></code> should point to an unitialized roc_endpoint pointer</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if endpoint was successfully allocated and initialized</p></li>
<li><p>returns a negative value on invalid arguments</p></li>
<li><p>returns a negative value on allocation failure</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>passes the ownership of <code class="docutils literal notranslate"><span class="pre">result</span></code> to the user; the user is responsible to call <a class="reference internal" href="#endpoint_8h_1a8644e1ba2abe414cbdcba203518cd71c"><span class="std std-ref">roc_endpoint_deallocate()</span></a> to free it </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_endpoint_set_uri">
<span class="target" id="endpoint_8h_1af73cc0bcac09a9f5ca7a2d2ae82ebc31"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_endpoint_set_uri</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_endpoint" title="roc_endpoint"><span class="n"><span class="pre">roc_endpoint</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endpoint</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uri</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_endpoint_set_uri" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set endpoint URI. </p>
<p>Parses and sets endpoint URI. Overrides or clears each URI component.</p>
<p>On failure, invalidates endpoint URI. The endpoint becomes invalid until its URI or every individual component is successfully set.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">endpoint</span></code> should point to initialized endpoint</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uri</span></code> should be a valid endpoint URI</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if URI was successfully parsed and set</p></li>
<li><p>returns a negative value on invalid arguments</p></li>
<li><p>returns a negative value on allocation failure</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">uri</span></code>; it may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_endpoint_set_protocol">
<span class="target" id="endpoint_8h_1ae82861c71826fb6a2d967bf3037b31ef"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_endpoint_set_protocol</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_endpoint" title="roc_endpoint"><span class="n"><span class="pre">roc_endpoint</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endpoint</span></span>, <a class="reference internal" href="#c.roc_protocol" title="roc_protocol"><span class="n"><span class="pre">roc_protocol</span></span></a><span class="w"> </span><span class="n"><span class="pre">proto</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_endpoint_set_protocol" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set endpoint protocol (scheme). </p>
<p>On failure, invalidates endpoint protocol. The endpoint becomes invalid until its protocol is successfully set.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">endpoint</span></code> should point to initialized endpoint</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">proto</span></code> defines new protocol</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if protocol was successfully set</p></li>
<li><p>returns a negative value on invalid arguments</p></li>
<li><p>returns a negative value if protocol is incompatible with other URI parameters </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_endpoint_set_host">
<span class="target" id="endpoint_8h_1ad3e093d9c250aeec4bd1bbce68491ce7"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_endpoint_set_host</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_endpoint" title="roc_endpoint"><span class="n"><span class="pre">roc_endpoint</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endpoint</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">host</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_endpoint_set_host" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set endpoint host. </p>
<p>On failure, invalidates endpoint host. The endpoint becomes invalid until its host is successfully set.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">endpoint</span></code> should point to initialized endpoint</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">host</span></code> specifies FQDN, IPv4 address, or IPv6 address</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if host was successfully set</p></li>
<li><p>returns a negative value on invalid arguments</p></li>
<li><p>returns a negative value on allocation failure</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">host</span></code>; it may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_endpoint_set_port">
<span class="target" id="endpoint_8h_1a8824f3ddd7330c004150132d83ba1756"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_endpoint_set_port</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_endpoint" title="roc_endpoint"><span class="n"><span class="pre">roc_endpoint</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endpoint</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">port</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_endpoint_set_port" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set endpoint port. </p>
<p>When binding an endpoint, the port may be set to zero to select a random port. The selected port will be then written back to the endpoint. When connecting an endpoint, the port should be positive.</p>
<p>If port is not set, the standard port for endpoint protocol is used. This is allowed only if the protocol defines its standard port.</p>
<p>If port is already set, it can be unset by setting to special value “-1”.</p>
<p>On failure, invalidates endpoint port. The endpoint becomes invalid until its port is successfully set.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">endpoint</span></code> should point to initialized endpoint</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port</span></code> specifies UDP or TCP port in range [0; 65535]</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if port was successfully set</p></li>
<li><p>returns a negative value on invalid arguments </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_endpoint_set_resource">
<span class="target" id="endpoint_8h_1a88551fc32963b68f0ecc0c4cbbe7be6f"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_endpoint_set_resource</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_endpoint" title="roc_endpoint"><span class="n"><span class="pre">roc_endpoint</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endpoint</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">encoded_resource</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_endpoint_set_resource" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set endpoint resource (path and query). </p>
<p>Path and query are both optional. Any of them may be omitted. If path is present, it should be absolute.</p>
<p>The given resource should be percent-encoded by user if it contains special characters. It may be inserted into the URI as is.</p>
<p>If resource is already set, it can be unset by setting to NULL or “”.</p>
<p>On failure, invalidates endpoint resource. The endpoint becomes invalid until its resource is successfully set.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">endpoint</span></code> should point to initialized endpoint</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">encoded_resource</span></code> specifies percent-encoded path and query</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if resource was successfully set</p></li>
<li><p>returns a negative value on invalid arguments</p></li>
<li><p>returns a negative value on allocation failure</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>doesn’t take or share the ownership of <code class="docutils literal notranslate"><span class="pre">encoded_resource</span></code>; it may be safely deallocated after the function returns </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_endpoint_get_uri">
<span class="target" id="endpoint_8h_1ad39e3e799b1a0850aa2d3c42d9a8a270"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_endpoint_get_uri</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_endpoint" title="roc_endpoint"><span class="n"><span class="pre">roc_endpoint</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endpoint</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bufsz</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_endpoint_get_uri" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get endpoint URI. </p>
<p>Formats endpoint URI to user-provided buffer.</p>
<p>If the function succeeds, the output string is zero-terminated. No matter whether the function succeeds or fails, <code class="docutils literal notranslate"><span class="pre">bufsz</span></code> is updated with the actual output string length, including terminating zero byte. <code class="docutils literal notranslate"><span class="pre">buf</span></code> may be NULL; in this case nothing is written, but <code class="docutils literal notranslate"><span class="pre">bufsz</span></code> is still updated. This can be used to determine the proper buffer size in before.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">endpoint</span></code> should point to initialized endpoint</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">buf</span></code> should point to a buffer of <code class="docutils literal notranslate"><span class="pre">bufsz</span></code> bytes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufsz</span></code> defines the buffer size</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if URI was successfully formatted</p></li>
<li><p>returns a negative value on invalid arguments</p></li>
<li><p>returns a negative value if endpoint URI is not set</p></li>
<li><p>returns a negative value if buffer is too small </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_endpoint_get_protocol">
<span class="target" id="endpoint_8h_1a4be0d0839480cc72dde164eb7ed6d96f"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_endpoint_get_protocol</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_endpoint" title="roc_endpoint"><span class="n"><span class="pre">roc_endpoint</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endpoint</span></span>, <a class="reference internal" href="#c.roc_protocol" title="roc_protocol"><span class="n"><span class="pre">roc_protocol</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">proto</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_endpoint_get_protocol" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get endpoint protocol (scheme). </p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">endpoint</span></code> should point to initialized endpoint</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">proto</span></code> should point to a variable where to write the protocol</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if protocol was successfully written</p></li>
<li><p>returns a negative value if endpoint protocol is not set</p></li>
<li><p>returns a negative value on invalid arguments </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_endpoint_get_host">
<span class="target" id="endpoint_8h_1a3c70d3114b519e41cf58a981051dd7d6"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_endpoint_get_host</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_endpoint" title="roc_endpoint"><span class="n"><span class="pre">roc_endpoint</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endpoint</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bufsz</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_endpoint_get_host" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get endpoint host. </p>
<p>Formats endpoint URI host to user-provided buffer.</p>
<p>If the function succeeds, the output string is zero-terminated. No matter whether the function succeeds or fails, <code class="docutils literal notranslate"><span class="pre">bufsz</span></code> is updated with the actual output string length, including terminating zero byte. <code class="docutils literal notranslate"><span class="pre">buf</span></code> may be NULL; in this case nothing is written, but <code class="docutils literal notranslate"><span class="pre">bufsz</span></code> is still updated. This can be used to determine the proper buffer size in before.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">endpoint</span></code> should point to initialized endpoint</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">buf</span></code> should point to a buffer of <code class="docutils literal notranslate"><span class="pre">bufsz</span></code> bytes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufsz</span></code> defines the buffer size</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if host was successfully formatted</p></li>
<li><p>returns a negative value if endpoint host is not set</p></li>
<li><p>returns a negative value on invalid arguments</p></li>
<li><p>returns a negative value if buffer is too small </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_endpoint_get_port">
<span class="target" id="endpoint_8h_1ab0129a89dc354f2f3fe441c2ab51c62d"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_endpoint_get_port</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_endpoint" title="roc_endpoint"><span class="n"><span class="pre">roc_endpoint</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endpoint</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_endpoint_get_port" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get endpoint port. </p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">endpoint</span></code> should point to initialized endpoint</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port</span></code> should point to a variable where to write the port</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if port was successfully written</p></li>
<li><p>returns a negative value if endpoint port is not set</p></li>
<li><p>returns a negative value on invalid arguments </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_endpoint_get_resource">
<span class="target" id="endpoint_8h_1a0a1bb408cdd8b5fb03b7af5b69adb85e"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_endpoint_get_resource</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_endpoint" title="roc_endpoint"><span class="n"><span class="pre">roc_endpoint</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endpoint</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bufsz</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_endpoint_get_resource" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get endpoint resource (path and query). </p>
<p>Formats endpoint URI resource to user-provided buffer. The written resource is percent-encoded.</p>
<p>If the function succeeds, the output string is zero-terminated. No matter whether the function succeeds or fails, <code class="docutils literal notranslate"><span class="pre">bufsz</span></code> is updated with the actual output string length, including terminating zero byte. <code class="docutils literal notranslate"><span class="pre">buf</span></code> may be NULL; in this case nothing is written, but <code class="docutils literal notranslate"><span class="pre">bufsz</span></code> is still updated. This can be used to determine the proper buffer size in before.</p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">endpoint</span></code> should point to initialized endpoint</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">buf</span></code> should point to a buffer of <code class="docutils literal notranslate"><span class="pre">bufsz</span></code> bytes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufsz</span></code> defines the buffer size</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if resource was successfully formatted</p></li>
<li><p>returns a negative value if neither of endpoint path and query is set</p></li>
<li><p>returns a negative value on invalid arguments</p></li>
<li><p>returns a negative value if buffer is too small </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_endpoint_deallocate">
<span class="target" id="endpoint_8h_1a8644e1ba2abe414cbdcba203518cd71c"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_endpoint_deallocate</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_endpoint" title="roc_endpoint"><span class="n"><span class="pre">roc_endpoint</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endpoint</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_endpoint_deallocate" title="Link to this definition">¶</a><br /></dt>
<dd><p>Deinitialize and deallocate endpoint. </p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">endpoint</span></code> should point to initialized endpoint</p></li>
</ul>
</p>
<p><strong>Returns</strong><ul class="simple">
<li><p>returns zero if endpoint was successfully deallocated</p></li>
<li><p>returns a negative value on invalid arguments</p></li>
</ul>
</p>
<p><strong>Ownership</strong><ul class="simple">
<li><p>ends the user ownership of <code class="docutils literal notranslate"><span class="pre">endpoint</span></code>; it can’t be used anymore after the function returns </p></li>
</ul>
</p>
</dd></dl>

</section>
<section id="roc-config">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">roc_config</a><a class="headerlink" href="#roc-config" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;roc/config.h&gt;</span>
</pre></div>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.roc_slot">
<span class="target" id="config_8h_1a9af284ec011da4d12d871589bb091c04"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_slot</span></span></span><a class="headerlink" href="#c.roc_slot" title="Link to this definition">¶</a><br /></dt>
<dd><p>Network slot. </p>
<p>A node (sender or receiver) may have multiple slots, which may be independently bound or connected. You can use multiple slots on sender to connect it to multiple receiver addresses, and you can use multiple slots on receiver to bind it to multiple receiver addresses.</p>
<p>Slots are numbered from zero and are created implicitly. Just specify slot index when binding or connecting endpoint, and slot will be automatically created if it was not created yet. Numbers does not need to be continuous and can be arbitrary.</p>
<p>In simple cases, when one slot is enough, just use <code class="docutils literal notranslate"><span class="pre">ROC_SLOT_DEFAULT</span></code>.</p>
<p>Inside each slot, there can be up to one endpoint for each interface type. See roc_interface for details. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.ROC_SLOT_DEFAULT">
<span class="target" id="config_8h_1ab535ee1f206672575178dbfb9d262540"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_slot" title="roc_slot"><span class="n"><span class="pre">roc_slot</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_SLOT_DEFAULT</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">0</span></span><a class="headerlink" href="#c.ROC_SLOT_DEFAULT" title="Link to this definition">¶</a><br /></dt>
<dd><p>Alias for the slot with index zero. </p>
<p>Has no special meaning, exists just for convenience. <div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#config_8h_1a9af284ec011da4d12d871589bb091c04"><span class="std std-ref">roc_slot</span></a></p>
</div>
</p>
</dd></dl>

<dl class="c enum">
<dt class="sig sig-object c" id="c.roc_interface">
<span class="target" id="config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ad"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_interface</span></span></span><a class="headerlink" href="#c.roc_interface" title="Link to this definition">¶</a><br /></dt>
<dd><p>Network interface. </p>
<p>Interface is a way to access the node (sender or receiver) via network.</p>
<p>Each node slot has multiple interfaces, one of each type. The user interconnects nodes by binding one of the first node’s interfaces to an URI and then connecting the corresponding second node’s interface to that URI.</p>
<p>A URI is represented by <a class="reference internal" href="#endpoint_8h_1a062c7188419cb9fb84473cab4f98d253"><span class="std std-ref">roc_endpoint</span></a> object.</p>
<p>The interface defines the type of the communication with the remote node and the set of protocols (URI schemes) that can be used with this particular interface.</p>
<p><code class="docutils literal notranslate"><span class="pre">ROC_INTERFACE_CONSOLIDATED</span></code> is an interface for high-level protocols which automatically manage all necessary communication: transport streams, control messages, parameter negotiation, etc. When a consolidated connection is established, nodes may automatically setup lower-level interfaces like <code class="docutils literal notranslate"><span class="pre">ROC_INTERFACE_AUDIO_SOURCE</span></code>, <code class="docutils literal notranslate"><span class="pre">ROC_INTERFACE_AUDIO_REPAIR</span></code>, and <code class="docutils literal notranslate"><span class="pre">ROC_INTERFACE_AUDIO_CONTROL</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">ROC_INTERFACE_CONSOLIDATED</span></code> is mutually exclusive with lower-level interfaces. In most cases, the user needs only <code class="docutils literal notranslate"><span class="pre">ROC_INTERFACE_CONSOLIDATED</span></code>. However, the lower-level interfaces may be useful if an external signaling mechanism is used or for compatibility with third-party software.</p>
<p><code class="docutils literal notranslate"><span class="pre">ROC_INTERFACE_AUDIO_SOURCE</span></code> and <code class="docutils literal notranslate"><span class="pre">ROC_INTERFACE_AUDIO_REPAIR</span></code> are lower-level unidirectional transport-only interfaces. The first is used to transmit audio stream, and the second is used to transmit redundant repair stream, if FEC is enabled.</p>
<p><code class="docutils literal notranslate"><span class="pre">ROC_INTERFACE_AUDIO_CONTROL</span></code> is a lower-level interface for control streams. If you use <code class="docutils literal notranslate"><span class="pre">ROC_INTERFACE_AUDIO_SOURCE</span></code> and <code class="docutils literal notranslate"><span class="pre">ROC_INTERFACE_AUDIO_REPAIR</span></code>, you usually also need to use <code class="docutils literal notranslate"><span class="pre">ROC_INTERFACE_AUDIO_CONTROL</span></code> to enable carrying additional non-transport information. </p>
<p><em>Values:</em></p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_interface.ROC_INTERFACE_CONSOLIDATED">
<span class="target" id="config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada6cc2c48ad02f079083752725486e16c4"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_INTERFACE_CONSOLIDATED</span></span></span><a class="headerlink" href="#c.roc_interface.ROC_INTERFACE_CONSOLIDATED" title="Link to this definition">¶</a><br /></dt>
<dd><p>Interface that consolidates all types of streams (source, repair, control). </p>
<p>Allowed operations:<ul class="simple">
<li><p>bind (sender, receiver)</p></li>
<li><p>connect (sender, receiver)</p></li>
</ul>
</p>
<p>Allowed protocols:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a18b575fc16a97c450d1cd364057d42d3"><span class="std std-ref">ROC_PROTO_RTSP</span></a></p></li>
</ul>
</p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_interface.ROC_INTERFACE_AUDIO_SOURCE">
<span class="target" id="config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada3475b769d44ad2d7a2fc6a77ea4b56f4"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_INTERFACE_AUDIO_SOURCE</span></span></span><a class="headerlink" href="#c.roc_interface.ROC_INTERFACE_AUDIO_SOURCE" title="Link to this definition">¶</a><br /></dt>
<dd><p>Interface for audio stream source data. </p>
<p>Allowed operations:<ul class="simple">
<li><p>bind (receiver)</p></li>
<li><p>connect (sender)</p></li>
</ul>
</p>
<p>Allowed protocols:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516ada758c721fa39b567b0f89e38fa29edb"><span class="std std-ref">ROC_PROTO_RTP</span></a></p></li>
<li><p><a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a15335419340ecc17b7391770c1d5a4e1"><span class="std std-ref">ROC_PROTO_RTP_RS8M_SOURCE</span></a></p></li>
<li><p><a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a7bee9e5bd2d93c4c5247903173e03ad2"><span class="std std-ref">ROC_PROTO_RTP_LDPC_SOURCE</span></a></p></li>
</ul>
</p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_interface.ROC_INTERFACE_AUDIO_REPAIR">
<span class="target" id="config_8h_1aa9b0c3341ee88b9e51876155b3f5d3adad3274771f2022355b75bdb0ccd3e9477"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_INTERFACE_AUDIO_REPAIR</span></span></span><a class="headerlink" href="#c.roc_interface.ROC_INTERFACE_AUDIO_REPAIR" title="Link to this definition">¶</a><br /></dt>
<dd><p>Interface for audio stream repair data. </p>
<p>Allowed operations:<ul class="simple">
<li><p>bind (receiver)</p></li>
<li><p>connect (sender)</p></li>
</ul>
</p>
<p>Allowed protocols:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a633ff1a3684f0aac55f9d9026986d182"><span class="std std-ref">ROC_PROTO_RS8M_REPAIR</span></a></p></li>
<li><p><a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a6fbfad98e2c22513cdb30a0935d7afe7"><span class="std std-ref">ROC_PROTO_LDPC_REPAIR</span></a></p></li>
</ul>
</p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_interface.ROC_INTERFACE_AUDIO_CONTROL">
<span class="target" id="config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada434747ad3b00f5ab653adaeb2ccd6a08"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_INTERFACE_AUDIO_CONTROL</span></span></span><a class="headerlink" href="#c.roc_interface.ROC_INTERFACE_AUDIO_CONTROL" title="Link to this definition">¶</a><br /></dt>
<dd><p>Interface for audio control messages. </p>
<p>Allowed operations:<ul class="simple">
<li><p>bind (sender, receiver)</p></li>
<li><p>connect (sender, receiver)</p></li>
</ul>
</p>
<p>Allowed protocols:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516afcf3067776b830835da275d3265be63b"><span class="std std-ref">ROC_PROTO_RTCP</span></a></p></li>
</ul>
</p>
</dd></dl>

</dd></dl>

<dl class="c enum">
<dt class="sig sig-object c" id="c.roc_protocol">
<span class="target" id="config_8h_1a89697f253e0644d6f738fecca34a2516"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_protocol</span></span></span><a class="headerlink" href="#c.roc_protocol" title="Link to this definition">¶</a><br /></dt>
<dd><p>Network protocol. </p>
<p>Defines URI scheme of <a class="reference internal" href="#endpoint_8h_1a062c7188419cb9fb84473cab4f98d253"><span class="std std-ref">roc_endpoint</span></a>. </p>
<p><em>Values:</em></p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_protocol.ROC_PROTO_RTSP">
<span class="target" id="config_8h_1a89697f253e0644d6f738fecca34a2516a18b575fc16a97c450d1cd364057d42d3"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_PROTO_RTSP</span></span></span><a class="headerlink" href="#c.roc_protocol.ROC_PROTO_RTSP" title="Link to this definition">¶</a><br /></dt>
<dd><p>RTSP 1.0 (RFC 2326) or RTSP 2.0 (RFC 7826). </p>
<p>Interfaces:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada6cc2c48ad02f079083752725486e16c4"><span class="std std-ref">ROC_INTERFACE_CONSOLIDATED</span></a></p></li>
</ul>
</p>
<p>Transports:<ul class="simple">
<li><p>for signaling: TCP</p></li>
<li><p>for media: RTP and RTCP over UDP or TCP </p></li>
</ul>
</p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_protocol.ROC_PROTO_RTP">
<span class="target" id="config_8h_1a89697f253e0644d6f738fecca34a2516ada758c721fa39b567b0f89e38fa29edb"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_PROTO_RTP</span></span></span><a class="headerlink" href="#c.roc_protocol.ROC_PROTO_RTP" title="Link to this definition">¶</a><br /></dt>
<dd><p>RTP over UDP (RFC 3550). </p>
<p>Interfaces:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada3475b769d44ad2d7a2fc6a77ea4b56f4"><span class="std std-ref">ROC_INTERFACE_AUDIO_SOURCE</span></a></p></li>
</ul>
</p>
<p>Transports:<ul class="simple">
<li><p>UDP</p></li>
</ul>
</p>
<p>Audio encodings:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1a950f4fed330b3c6d85f2b4cf12134043a3e23e1512e378a75f03c5ae7d11cc2e2"><span class="std std-ref">ROC_PACKET_ENCODING_AVP_L16_MONO</span></a></p></li>
<li><p><a class="reference internal" href="#config_8h_1a950f4fed330b3c6d85f2b4cf12134043a7a4ab0d84af7927fa75d3d195c73e994"><span class="std std-ref">ROC_PACKET_ENCODING_AVP_L16_STEREO</span></a></p></li>
<li><p>encodings registered using <a class="reference internal" href="#context_8h_1a43ff1ec42c996b34af90cf8a9a8b900c"><span class="std std-ref">roc_context_register_encoding()</span></a></p></li>
</ul>
</p>
<p>FEC encodings:<ul class="simple">
<li><p>none </p></li>
</ul>
</p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_protocol.ROC_PROTO_RTP_RS8M_SOURCE">
<span class="target" id="config_8h_1a89697f253e0644d6f738fecca34a2516a15335419340ecc17b7391770c1d5a4e1"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_PROTO_RTP_RS8M_SOURCE</span></span></span><a class="headerlink" href="#c.roc_protocol.ROC_PROTO_RTP_RS8M_SOURCE" title="Link to this definition">¶</a><br /></dt>
<dd><p>RTP source packet (RFC 3550) + FECFRAME Reed-Solomon footer (RFC 6865) with m=8. </p>
<p>Interfaces:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada3475b769d44ad2d7a2fc6a77ea4b56f4"><span class="std std-ref">ROC_INTERFACE_AUDIO_SOURCE</span></a></p></li>
</ul>
</p>
<p>Transports:<ul class="simple">
<li><p>UDP</p></li>
</ul>
</p>
<p>Audio encodings:<ul class="simple">
<li><p>similar to <a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516ada758c721fa39b567b0f89e38fa29edb"><span class="std std-ref">ROC_PROTO_RTP</span></a></p></li>
</ul>
</p>
<p>FEC encodings:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1afa58151e9df856eec5851b59815db865ab65967c71eebe075df069897f6857d34"><span class="std std-ref">ROC_FEC_ENCODING_RS8M</span></a></p></li>
</ul>
</p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_protocol.ROC_PROTO_RS8M_REPAIR">
<span class="target" id="config_8h_1a89697f253e0644d6f738fecca34a2516a633ff1a3684f0aac55f9d9026986d182"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_PROTO_RS8M_REPAIR</span></span></span><a class="headerlink" href="#c.roc_protocol.ROC_PROTO_RS8M_REPAIR" title="Link to this definition">¶</a><br /></dt>
<dd><p>FEC repair packet + FECFRAME Reed-Solomon header (RFC 6865) with m=8. </p>
<p>Interfaces:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3adad3274771f2022355b75bdb0ccd3e9477"><span class="std std-ref">ROC_INTERFACE_AUDIO_REPAIR</span></a></p></li>
</ul>
</p>
<p>Transports:<ul class="simple">
<li><p>UDP</p></li>
</ul>
</p>
<p>FEC encodings:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1afa58151e9df856eec5851b59815db865ab65967c71eebe075df069897f6857d34"><span class="std std-ref">ROC_FEC_ENCODING_RS8M</span></a></p></li>
</ul>
</p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_protocol.ROC_PROTO_RTP_LDPC_SOURCE">
<span class="target" id="config_8h_1a89697f253e0644d6f738fecca34a2516a7bee9e5bd2d93c4c5247903173e03ad2"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_PROTO_RTP_LDPC_SOURCE</span></span></span><a class="headerlink" href="#c.roc_protocol.ROC_PROTO_RTP_LDPC_SOURCE" title="Link to this definition">¶</a><br /></dt>
<dd><p>RTP source packet (RFC 3550) + FECFRAME LDPC-Staircase footer (RFC 6816). </p>
<p>Interfaces:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada3475b769d44ad2d7a2fc6a77ea4b56f4"><span class="std std-ref">ROC_INTERFACE_AUDIO_SOURCE</span></a></p></li>
</ul>
</p>
<p>Transports:<ul class="simple">
<li><p>UDP</p></li>
</ul>
</p>
<p>Audio encodings:<ul class="simple">
<li><p>similar to <a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516ada758c721fa39b567b0f89e38fa29edb"><span class="std std-ref">ROC_PROTO_RTP</span></a></p></li>
</ul>
</p>
<p>FEC encodings:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1afa58151e9df856eec5851b59815db865a912185a3eb30567fd94544779d333618"><span class="std std-ref">ROC_FEC_ENCODING_LDPC_STAIRCASE</span></a></p></li>
</ul>
</p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_protocol.ROC_PROTO_LDPC_REPAIR">
<span class="target" id="config_8h_1a89697f253e0644d6f738fecca34a2516a6fbfad98e2c22513cdb30a0935d7afe7"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_PROTO_LDPC_REPAIR</span></span></span><a class="headerlink" href="#c.roc_protocol.ROC_PROTO_LDPC_REPAIR" title="Link to this definition">¶</a><br /></dt>
<dd><p>FEC repair packet + FECFRAME LDPC-Staircase header (RFC 6816). </p>
<p>Interfaces:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3adad3274771f2022355b75bdb0ccd3e9477"><span class="std std-ref">ROC_INTERFACE_AUDIO_REPAIR</span></a></p></li>
</ul>
</p>
<p>Transports:<ul class="simple">
<li><p>UDP</p></li>
</ul>
</p>
<p>FEC encodings:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1afa58151e9df856eec5851b59815db865a912185a3eb30567fd94544779d333618"><span class="std std-ref">ROC_FEC_ENCODING_LDPC_STAIRCASE</span></a></p></li>
</ul>
</p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_protocol.ROC_PROTO_RTCP">
<span class="target" id="config_8h_1a89697f253e0644d6f738fecca34a2516afcf3067776b830835da275d3265be63b"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_PROTO_RTCP</span></span></span><a class="headerlink" href="#c.roc_protocol.ROC_PROTO_RTCP" title="Link to this definition">¶</a><br /></dt>
<dd><p>RTCP over UDP (RFC 3550). </p>
<p>Interfaces:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1aa9b0c3341ee88b9e51876155b3f5d3ada434747ad3b00f5ab653adaeb2ccd6a08"><span class="std std-ref">ROC_INTERFACE_AUDIO_CONTROL</span></a></p></li>
</ul>
</p>
<p>Transports:<ul class="simple">
<li><p>UDP </p></li>
</ul>
</p>
</dd></dl>

</dd></dl>

<dl class="c enum">
<dt class="sig sig-object c" id="c.roc_packet_encoding">
<span class="target" id="config_8h_1a950f4fed330b3c6d85f2b4cf12134043"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_packet_encoding</span></span></span><a class="headerlink" href="#c.roc_packet_encoding" title="Link to this definition">¶</a><br /></dt>
<dd><p>Packet encoding. </p>
<p>Each packet encoding defines sample format, channel layout, and rate. Each packet encoding is caompatible with specific protocols. </p>
<p><em>Values:</em></p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_packet_encoding.ROC_PACKET_ENCODING_AVP_L16_MONO">
<span class="target" id="config_8h_1a950f4fed330b3c6d85f2b4cf12134043a3e23e1512e378a75f03c5ae7d11cc2e2"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_PACKET_ENCODING_AVP_L16_MONO</span></span></span><a class="headerlink" href="#c.roc_packet_encoding.ROC_PACKET_ENCODING_AVP_L16_MONO" title="Link to this definition">¶</a><br /></dt>
<dd><p>PCM signed 16-bit, 1 channel, 44100 rate. </p>
<p>Represents 1-channel L16 stereo encoding from RTP A/V Profile (RFC 3551). Uses uncompressed samples coded as interleaved 16-bit signed big-endian integers in two’s complement notation.</p>
<p>Supported by protocols:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516ada758c721fa39b567b0f89e38fa29edb"><span class="std std-ref">ROC_PROTO_RTP</span></a></p></li>
<li><p><a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a15335419340ecc17b7391770c1d5a4e1"><span class="std std-ref">ROC_PROTO_RTP_RS8M_SOURCE</span></a></p></li>
<li><p><a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a7bee9e5bd2d93c4c5247903173e03ad2"><span class="std std-ref">ROC_PROTO_RTP_LDPC_SOURCE</span></a></p></li>
</ul>
</p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_packet_encoding.ROC_PACKET_ENCODING_AVP_L16_STEREO">
<span class="target" id="config_8h_1a950f4fed330b3c6d85f2b4cf12134043a7a4ab0d84af7927fa75d3d195c73e994"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_PACKET_ENCODING_AVP_L16_STEREO</span></span></span><a class="headerlink" href="#c.roc_packet_encoding.ROC_PACKET_ENCODING_AVP_L16_STEREO" title="Link to this definition">¶</a><br /></dt>
<dd><p>PCM signed 16-bit, 2 channels, 44100 rate. </p>
<p>Represents 2-channel L16 stereo encoding from RTP A/V Profile (RFC 3551). Uses uncompressed samples coded as interleaved 16-bit signed big-endian integers in two’s complement notation.</p>
<p>Supported by protocols:<ul class="simple">
<li><p><a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516ada758c721fa39b567b0f89e38fa29edb"><span class="std std-ref">ROC_PROTO_RTP</span></a></p></li>
<li><p><a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a15335419340ecc17b7391770c1d5a4e1"><span class="std std-ref">ROC_PROTO_RTP_RS8M_SOURCE</span></a></p></li>
<li><p><a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a7bee9e5bd2d93c4c5247903173e03ad2"><span class="std std-ref">ROC_PROTO_RTP_LDPC_SOURCE</span></a></p></li>
</ul>
</p>
</dd></dl>

</dd></dl>

<dl class="c enum">
<dt class="sig sig-object c" id="c.roc_fec_encoding">
<span class="target" id="config_8h_1afa58151e9df856eec5851b59815db865"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_fec_encoding</span></span></span><a class="headerlink" href="#c.roc_fec_encoding" title="Link to this definition">¶</a><br /></dt>
<dd><p>Forward Error Correction encoding. </p>
<p>Each FEC encoding is caompatible with specific protocols. </p>
<p><em>Values:</em></p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_fec_encoding.ROC_FEC_ENCODING_DISABLE">
<span class="target" id="config_8h_1afa58151e9df856eec5851b59815db865a514d4be99dce993ea190b680ec5b9c6b"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_FEC_ENCODING_DISABLE</span></span></span><a class="headerlink" href="#c.roc_fec_encoding.ROC_FEC_ENCODING_DISABLE" title="Link to this definition">¶</a><br /></dt>
<dd><p>No FEC encoding. </p>
<p>Compatible with <a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516ada758c721fa39b567b0f89e38fa29edb"><span class="std std-ref">ROC_PROTO_RTP</span></a> protocol.</p>
<p>Pros:<ul class="simple">
<li><p>compatible with third-party software that does not support FECFRAME</p></li>
</ul>
</p>
<p>Cons:<ul class="simple">
<li><p>no packet recovery </p></li>
</ul>
</p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_fec_encoding.ROC_FEC_ENCODING_DEFAULT">
<span class="target" id="config_8h_1afa58151e9df856eec5851b59815db865aa29108d2f101291a3b2b172c021037c2"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_FEC_ENCODING_DEFAULT</span></span></span><a class="headerlink" href="#c.roc_fec_encoding.ROC_FEC_ENCODING_DEFAULT" title="Link to this definition">¶</a><br /></dt>
<dd><p>Default FEC encoding. </p>
<p>Current default is <a class="reference internal" href="#config_8h_1afa58151e9df856eec5851b59815db865ab65967c71eebe075df069897f6857d34"><span class="std std-ref">ROC_FEC_ENCODING_RS8M</span></a>. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_fec_encoding.ROC_FEC_ENCODING_RS8M">
<span class="target" id="config_8h_1afa58151e9df856eec5851b59815db865ab65967c71eebe075df069897f6857d34"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_FEC_ENCODING_RS8M</span></span></span><a class="headerlink" href="#c.roc_fec_encoding.ROC_FEC_ENCODING_RS8M" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reed-Solomon FEC encoding (RFC 6865) with m=8. </p>
<p>Good for small block sizes (below 256 packets). Compatible with <a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a15335419340ecc17b7391770c1d5a4e1"><span class="std std-ref">ROC_PROTO_RTP_RS8M_SOURCE</span></a> and <a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a633ff1a3684f0aac55f9d9026986d182"><span class="std std-ref">ROC_PROTO_RS8M_REPAIR</span></a> protocols for source and repair endpoints.</p>
<p>Pros:<ul class="simple">
<li><p>good repair capabilities even on small block sizes</p></li>
</ul>
</p>
<p>Cons:<ul class="simple">
<li><p>high CPU usage on large block sizes </p></li>
</ul>
</p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_fec_encoding.ROC_FEC_ENCODING_LDPC_STAIRCASE">
<span class="target" id="config_8h_1afa58151e9df856eec5851b59815db865a912185a3eb30567fd94544779d333618"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_FEC_ENCODING_LDPC_STAIRCASE</span></span></span><a class="headerlink" href="#c.roc_fec_encoding.ROC_FEC_ENCODING_LDPC_STAIRCASE" title="Link to this definition">¶</a><br /></dt>
<dd><p>LDPC-Staircase FEC encoding (RFC 6816). </p>
<p>Good for large block sizes (above 1024 packets). Compatible with <a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a7bee9e5bd2d93c4c5247903173e03ad2"><span class="std std-ref">ROC_PROTO_RTP_LDPC_SOURCE</span></a> and <a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516a6fbfad98e2c22513cdb30a0935d7afe7"><span class="std std-ref">ROC_PROTO_LDPC_REPAIR</span></a> protocols for source and repair endpoints.</p>
<p>Pros:<ul class="simple">
<li><p>low CPU usage even on large block sizes</p></li>
</ul>
</p>
<p>Cons:<ul class="simple">
<li><p>low repair capabilities on small block sizes </p></li>
</ul>
</p>
</dd></dl>

</dd></dl>

<dl class="c enum">
<dt class="sig sig-object c" id="c.roc_format">
<span class="target" id="config_8h_1ac24a6637fefa48d61bb8631c25bde919"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_format</span></span></span><a class="headerlink" href="#c.roc_format" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sample format. </p>
<p>Defines how each sample is represented. Does not define channels layout and sample rate. </p>
<p><em>Values:</em></p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_format.ROC_FORMAT_PCM_FLOAT32">
<span class="target" id="config_8h_1ac24a6637fefa48d61bb8631c25bde919aa851fa1a679b2df37b113fefe53b98e1"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_FORMAT_PCM_FLOAT32</span></span></span><a class="headerlink" href="#c.roc_format.ROC_FORMAT_PCM_FLOAT32" title="Link to this definition">¶</a><br /></dt>
<dd><p>PCM floats. </p>
<p>Uncompressed samples coded as 32-bit native-endian floats in range [-1; 1]. Channels are interleaved, e.g. two channels are encoded as “L R L R …”. </p>
</dd></dl>

</dd></dl>

<dl class="c enum">
<dt class="sig sig-object c" id="c.roc_channel_layout">
<span class="target" id="config_8h_1a3c8d5dfce5e1fedb89979ecc410ed442"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_channel_layout</span></span></span><a class="headerlink" href="#c.roc_channel_layout" title="Link to this definition">¶</a><br /></dt>
<dd><p>Channel layout. </p>
<p>Defines number of channels and meaning of each channel. </p>
<p><em>Values:</em></p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_channel_layout.ROC_CHANNEL_LAYOUT_MULTITRACK">
<span class="target" id="config_8h_1a3c8d5dfce5e1fedb89979ecc410ed442aad1c5e55c6874ad4fdd56b0a38821686"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_CHANNEL_LAYOUT_MULTITRACK</span></span></span><a class="headerlink" href="#c.roc_channel_layout.ROC_CHANNEL_LAYOUT_MULTITRACK" title="Link to this definition">¶</a><br /></dt>
<dd><p>Multi-track audio. </p>
<p>In multitrack layout, stream contains multiple channels which represent independent “tracks” without any special meaning (unlike stereo or surround) and hence without any special processing or mapping.</p>
<p>The number of channels is arbitrary and is defined by <code class="docutils literal notranslate"><span class="pre">tracks</span></code> field of <a class="reference internal" href="#structroc__media__encoding"><span class="std std-ref">roc_media_encoding</span></a> struct. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_channel_layout.ROC_CHANNEL_LAYOUT_MONO">
<span class="target" id="config_8h_1a3c8d5dfce5e1fedb89979ecc410ed442a0813305bc2f21cd6bcb99f4fe57173bd"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_CHANNEL_LAYOUT_MONO</span></span></span><a class="headerlink" href="#c.roc_channel_layout.ROC_CHANNEL_LAYOUT_MONO" title="Link to this definition">¶</a><br /></dt>
<dd><p>Mono. </p>
<p>One channel with monophonic sound. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_channel_layout.ROC_CHANNEL_LAYOUT_STEREO">
<span class="target" id="config_8h_1a3c8d5dfce5e1fedb89979ecc410ed442a9dfb0245a8a8f2af5bbd42640638f85c"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_CHANNEL_LAYOUT_STEREO</span></span></span><a class="headerlink" href="#c.roc_channel_layout.ROC_CHANNEL_LAYOUT_STEREO" title="Link to this definition">¶</a><br /></dt>
<dd><p>Stereo. </p>
<p>Two channels: left, right. </p>
</dd></dl>

</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.roc_media_encoding">
<span class="target" id="structroc__media__encoding"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_media_encoding</span></span></span><a class="headerlink" href="#c.roc_media_encoding" title="Link to this definition">¶</a><br /></dt>
<dd><p>Media encoding. </p>
<p>Defines format and parameters of samples encoded in frames or packets. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.roc_media_encoding.rate">
<span class="target" id="structroc__media__encoding_1af361973e5084b73cf92eb106bff98224"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rate</span></span></span><a class="headerlink" href="#c.roc_media_encoding.rate" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sample frequency. </p>
<p>Defines number of samples per channel per second (e.g. 44100). </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_media_encoding.format">
<span class="target" id="structroc__media__encoding_1a85249870e630ca99a571e1f78e2ce478"></span><a class="reference internal" href="#c.roc_format" title="roc_format"><span class="n"><span class="pre">roc_format</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">format</span></span></span><a class="headerlink" href="#c.roc_media_encoding.format" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sample format. </p>
<p>Defines sample precision and encoding. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_media_encoding.channels">
<span class="target" id="structroc__media__encoding_1af50ec588653b32ce3cc0447e464eae96"></span><a class="reference internal" href="#c.roc_channel_layout" title="roc_channel_layout"><span class="n"><span class="pre">roc_channel_layout</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">channels</span></span></span><a class="headerlink" href="#c.roc_media_encoding.channels" title="Link to this definition">¶</a><br /></dt>
<dd><p>Channel layout. </p>
<p>Defines number of channels and meaning of each channel. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_media_encoding.tracks">
<span class="target" id="structroc__media__encoding_1a128f1b2a98b57efae713e9c104513564"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tracks</span></span></span><a class="headerlink" href="#c.roc_media_encoding.tracks" title="Link to this definition">¶</a><br /></dt>
<dd><p>Multi-track channel count. </p>
<p>If <code class="docutils literal notranslate"><span class="pre">channels</span></code> is <a class="reference internal" href="#config_8h_1a3c8d5dfce5e1fedb89979ecc410ed442aad1c5e55c6874ad4fdd56b0a38821686"><span class="std std-ref">ROC_CHANNEL_LAYOUT_MULTITRACK</span></a>, defines number of channels (which represent independent “tracks”). For other channel layouts should be zero.</p>
<p>Should be in range [1; 1024]. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="c enum">
<dt class="sig sig-object c" id="c.roc_clock_source">
<span class="target" id="config_8h_1add917f6cbdc964eb7a42f47769bc2407"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_clock_source</span></span></span><a class="headerlink" href="#c.roc_clock_source" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clock source for sender or receiver. </p>
<p>Defines wo is responsible to invoke read or write in proper time. </p>
<p><em>Values:</em></p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_clock_source.ROC_CLOCK_SOURCE_EXTERNAL">
<span class="target" id="config_8h_1add917f6cbdc964eb7a42f47769bc2407ac4b026fb3476ce4fed4f946c3fc9fd7a"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_CLOCK_SOURCE_EXTERNAL</span></span></span><a class="headerlink" href="#c.roc_clock_source.ROC_CLOCK_SOURCE_EXTERNAL" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sender or receiver is clocked by external user-defined clock. </p>
<p>Write and read operations are non-blocking. The user is responsible to call them in time, according to the external clock.</p>
<p>Use when samples source (from where you read them to pass to receiver) or destination (to where you write them after obtaining from sender) is active and has its own clock, e.g. it is a sound card. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_clock_source.ROC_CLOCK_SOURCE_INTERNAL">
<span class="target" id="config_8h_1add917f6cbdc964eb7a42f47769bc2407acf671d4c072d601ff4dfa293e6434767"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_CLOCK_SOURCE_INTERNAL</span></span></span><a class="headerlink" href="#c.roc_clock_source.ROC_CLOCK_SOURCE_INTERNAL" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sender or receiver is clocked by an internal pipeline clock. </p>
<p>Write and read operations are blocking. They automatically wait until it’s time to process the next bunch of samples according to the configured sample rate, based on a CPU timer.</p>
<p>Use when samples source (from where you read them to pass to receiver) or destination (to where you write them after obtaining from sender) is passive and does now have clock, e.g. it is a file on disk. </p>
</dd></dl>

</dd></dl>

<dl class="c enum">
<dt class="sig sig-object c" id="c.roc_clock_sync_backend">
<span class="target" id="config_8h_1a4adb4cf78bba94279e869840d505411a"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_clock_sync_backend</span></span></span><a class="headerlink" href="#c.roc_clock_sync_backend" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clock synchronization algorithm. </p>
<p>Defines how sender and receiver clocks are synchronized. </p>
<p><em>Values:</em></p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_clock_sync_backend.ROC_CLOCK_SYNC_BACKEND_DISABLE">
<span class="target" id="config_8h_1a4adb4cf78bba94279e869840d505411aaa120d8b7d406ac7f7d86da5cc3bb8dd9"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_CLOCK_SYNC_BACKEND_DISABLE</span></span></span><a class="headerlink" href="#c.roc_clock_sync_backend.ROC_CLOCK_SYNC_BACKEND_DISABLE" title="Link to this definition">¶</a><br /></dt>
<dd><p>Disable clock synchronization. </p>
<p>In this mode, sender and receiver clocks are not synchronized. This mode is generally not recommended, since clock drift will lead to periodic playback disruptions caused by underruns and overruns. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_clock_sync_backend.ROC_CLOCK_SYNC_BACKEND_DEFAULT">
<span class="target" id="config_8h_1a4adb4cf78bba94279e869840d505411aa1e4e148398f50c94e941fdb6304630b8"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_CLOCK_SYNC_BACKEND_DEFAULT</span></span></span><a class="headerlink" href="#c.roc_clock_sync_backend.ROC_CLOCK_SYNC_BACKEND_DEFAULT" title="Link to this definition">¶</a><br /></dt>
<dd><p>Default backend. </p>
<p>Current default is <code class="docutils literal notranslate"><span class="pre">ROC_CLOCK_SYNC_BACKEND_NIQ</span></code>. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_clock_sync_backend.ROC_CLOCK_SYNC_BACKEND_NIQ">
<span class="target" id="config_8h_1a4adb4cf78bba94279e869840d505411aaa7a5621b8ea8ff637a8e85f13d32e5dd"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_CLOCK_SYNC_BACKEND_NIQ</span></span></span><a class="headerlink" href="#c.roc_clock_sync_backend.ROC_CLOCK_SYNC_BACKEND_NIQ" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clock synchronization based on network incoming queue size. </p>
<p>In this mode, receiver monitors incoming queue size and adjusts playback clock speed to match the estimated capture clock speed.</p>
<p>Pros:<ul class="simple">
<li><p>works with any protocol (does not require RTCP or NTP)</p></li>
</ul>
</p>
<p>Cons:<ul class="simple">
<li><p>synchronizes only clock speed, but not position; different receivers will have different (constant) delays</p></li>
<li><p>affected by network jitter; spikes in packet delivery will cause slow oscillations in clock speed </p></li>
</ul>
</p>
</dd></dl>

</dd></dl>

<dl class="c enum">
<dt class="sig sig-object c" id="c.roc_clock_sync_profile">
<span class="target" id="config_8h_1a204b2f94f739da13c1db11f4548fc360"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_clock_sync_profile</span></span></span><a class="headerlink" href="#c.roc_clock_sync_profile" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clock synchronization profile. </p>
<p>Defines what latency and jitter are tolerated by clock synchronization algorithm. </p>
<p><em>Values:</em></p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_clock_sync_profile.ROC_CLOCK_SYNC_PROFILE_DEFAULT">
<span class="target" id="config_8h_1a204b2f94f739da13c1db11f4548fc360acafe13d79ed731e5d4ee847e4535fbb6"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_CLOCK_SYNC_PROFILE_DEFAULT</span></span></span><a class="headerlink" href="#c.roc_clock_sync_profile.ROC_CLOCK_SYNC_PROFILE_DEFAULT" title="Link to this definition">¶</a><br /></dt>
<dd><p>Default profile. </p>
<p>When <a class="reference internal" href="#config_8h_1a4adb4cf78bba94279e869840d505411aaa7a5621b8ea8ff637a8e85f13d32e5dd"><span class="std std-ref">ROC_CLOCK_SYNC_BACKEND_NIQ</span></a> is used, selects <a class="reference internal" href="#config_8h_1a204b2f94f739da13c1db11f4548fc360af4584abe2c267f79223ffb8415e4001b"><span class="std std-ref">ROC_CLOCK_SYNC_PROFILE_RESPONSIVE</span></a> if target latency is low, and <a class="reference internal" href="#config_8h_1a204b2f94f739da13c1db11f4548fc360a3eae3f1e8038bdc56e7377441d643838"><span class="std std-ref">ROC_CLOCK_SYNC_PROFILE_GRADUAL</span></a> if target latency is high. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_clock_sync_profile.ROC_CLOCK_SYNC_PROFILE_RESPONSIVE">
<span class="target" id="config_8h_1a204b2f94f739da13c1db11f4548fc360af4584abe2c267f79223ffb8415e4001b"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_CLOCK_SYNC_PROFILE_RESPONSIVE</span></span></span><a class="headerlink" href="#c.roc_clock_sync_profile.ROC_CLOCK_SYNC_PROFILE_RESPONSIVE" title="Link to this definition">¶</a><br /></dt>
<dd><p>Responsive clock adjustment. </p>
<p>Clock speed is adjusted quickly and accurately.</p>
<p>Requires high precision clock adjustment, hence recommended for use with <a class="reference internal" href="#config_8h_1a5671173735634f14066ec064a909f03ba0c095bc382f6b52f3e3665bdcf3ebe2c"><span class="std std-ref">ROC_RESAMPLER_BACKEND_BUILTIN</span></a>.</p>
<p>Pros:<ul class="simple">
<li><p>allows very low latency or synchronization error</p></li>
</ul>
</p>
<p>Cons:<ul class="simple">
<li><p>does not work well with some resampler backends</p></li>
<li><p>does not work well with <a class="reference internal" href="#config_8h_1a4adb4cf78bba94279e869840d505411aaa7a5621b8ea8ff637a8e85f13d32e5dd"><span class="std std-ref">ROC_CLOCK_SYNC_BACKEND_NIQ</span></a> if network jitter is high </p></li>
</ul>
</p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_clock_sync_profile.ROC_CLOCK_SYNC_PROFILE_GRADUAL">
<span class="target" id="config_8h_1a204b2f94f739da13c1db11f4548fc360a3eae3f1e8038bdc56e7377441d643838"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_CLOCK_SYNC_PROFILE_GRADUAL</span></span></span><a class="headerlink" href="#c.roc_clock_sync_profile.ROC_CLOCK_SYNC_PROFILE_GRADUAL" title="Link to this definition">¶</a><br /></dt>
<dd><p>Gradual clock adjustment. </p>
<p>Clock speed is adjusted slowly and smoothly.</p>
<p>Pros:<ul class="simple">
<li><p>works well even with high network jitter</p></li>
<li><p>works well with any resampler backend</p></li>
</ul>
</p>
<p>Cons:<ul class="simple">
<li><p>does not allow very low latency or synchronization error </p></li>
</ul>
</p>
</dd></dl>

</dd></dl>

<dl class="c enum">
<dt class="sig sig-object c" id="c.roc_resampler_backend">
<span class="target" id="config_8h_1a5671173735634f14066ec064a909f03b"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_resampler_backend</span></span></span><a class="headerlink" href="#c.roc_resampler_backend" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resampler backend. </p>
<p>Affects CPU usage, quality, and clock synchronization precision. Some backends may be disabled at build time. </p>
<p><em>Values:</em></p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_resampler_backend.ROC_RESAMPLER_BACKEND_DEFAULT">
<span class="target" id="config_8h_1a5671173735634f14066ec064a909f03bad721727ef5127b404cc9eecf229c07c9"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_RESAMPLER_BACKEND_DEFAULT</span></span></span><a class="headerlink" href="#c.roc_resampler_backend.ROC_RESAMPLER_BACKEND_DEFAULT" title="Link to this definition">¶</a><br /></dt>
<dd><p>Default backend. </p>
<p>Selects <a class="reference internal" href="#config_8h_1a5671173735634f14066ec064a909f03ba0c095bc382f6b52f3e3665bdcf3ebe2c"><span class="std std-ref">ROC_RESAMPLER_BACKEND_BUILTIN</span></a> when using <a class="reference internal" href="#config_8h_1a204b2f94f739da13c1db11f4548fc360af4584abe2c267f79223ffb8415e4001b"><span class="std std-ref">ROC_CLOCK_SYNC_PROFILE_RESPONSIVE</span></a>, or when SpeexDSP is disabled.</p>
<p>Otherwise, selects <a class="reference internal" href="#config_8h_1a5671173735634f14066ec064a909f03ba05fbe2e7edc9ae15aed8d0494103090c"><span class="std std-ref">ROC_RESAMPLER_BACKEND_SPEEX</span></a>. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_resampler_backend.ROC_RESAMPLER_BACKEND_BUILTIN">
<span class="target" id="config_8h_1a5671173735634f14066ec064a909f03ba0c095bc382f6b52f3e3665bdcf3ebe2c"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_RESAMPLER_BACKEND_BUILTIN</span></span></span><a class="headerlink" href="#c.roc_resampler_backend.ROC_RESAMPLER_BACKEND_BUILTIN" title="Link to this definition">¶</a><br /></dt>
<dd><p>CPU-intensive good-quality high-precision built-in resampler. </p>
<p>This backend controls clock speed with very high precision, and hence is useful when latency or synchronization error should be very low.</p>
<p>This backend has higher CPU usage, especially on high resampling quality and on CPUs with small L3 caches.</p>
<p>The implementation is based on bandlimited interpolation algorithm.</p>
<p>This backend is always available.</p>
<p>Recommended for <a class="reference internal" href="#config_8h_1a204b2f94f739da13c1db11f4548fc360af4584abe2c267f79223ffb8415e4001b"><span class="std std-ref">ROC_CLOCK_SYNC_PROFILE_RESPONSIVE</span></a> and on good CPUs. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_resampler_backend.ROC_RESAMPLER_BACKEND_SPEEX">
<span class="target" id="config_8h_1a5671173735634f14066ec064a909f03ba05fbe2e7edc9ae15aed8d0494103090c"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_RESAMPLER_BACKEND_SPEEX</span></span></span><a class="headerlink" href="#c.roc_resampler_backend.ROC_RESAMPLER_BACKEND_SPEEX" title="Link to this definition">¶</a><br /></dt>
<dd><p>Fast good-quality low-precision resampler based on SpeexDSP. </p>
<p>This backend has low CPU usage even on high resampler quality and cheap CPUs.</p>
<p>This backend controls clock speed with lower precision, and is not so good when latency or synchronization error should be very low.</p>
<p>This backend is available only when SpeexDSP was enabled at build time.</p>
<p>Recommended for <a class="reference internal" href="#config_8h_1a204b2f94f739da13c1db11f4548fc360a3eae3f1e8038bdc56e7377441d643838"><span class="std std-ref">ROC_CLOCK_SYNC_PROFILE_GRADUAL</span></a> and on cheap CPUs. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_resampler_backend.ROC_RESAMPLER_BACKEND_SPEEXDEC">
<span class="target" id="config_8h_1a5671173735634f14066ec064a909f03baa6a607b48cf08b32da2ad442adbc85a7"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_RESAMPLER_BACKEND_SPEEXDEC</span></span></span><a class="headerlink" href="#c.roc_resampler_backend.ROC_RESAMPLER_BACKEND_SPEEXDEC" title="Link to this definition">¶</a><br /></dt>
<dd><p>Fast medium-quality and medium-precision resampler combining SpeexDSP with decimation. </p>
<p>This backend uses SpeexDSP for converting between base rates (e.g. 44100 vs 48000) and decimation/expansion (dropping or duplicating samples) for clock drift compensation.</p>
<p>Typical decimation rate needed to compensate clock drift is below 0.5ms/second (20 samples/second on 48Khz), which gives tolerable quality despite usage of decimation, especially for speech.</p>
<p>When frame and packet sample rates are equal (e.g. both are 44100), only decimation stage is needed, and this becomes fastest possible backend working almost as fast as memcpy().</p>
<p>When frame and packet rates are different, usage of this backend compared to <code class="docutils literal notranslate"><span class="pre">ROC_RESAMPLER_BACKEND_SPEEX</span></code> allows to sacrify some quality, but somewhat improve scaling precision and CPU usage in return.</p>
<p>This backend is available only when SpeexDSP was enabled at build time.</p>
<p>Recommended when CPU resources are extremely limited. </p>
</dd></dl>

</dd></dl>

<dl class="c enum">
<dt class="sig sig-object c" id="c.roc_resampler_profile">
<span class="target" id="config_8h_1aaadff6355a4e2b6214c3c33ce939c26b"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_resampler_profile</span></span></span><a class="headerlink" href="#c.roc_resampler_profile" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resampler profile. </p>
<p>Affects CPU usage and quality. Each resampler backend treats profile in its own way. </p>
<p><em>Values:</em></p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_resampler_profile.ROC_RESAMPLER_PROFILE_DEFAULT">
<span class="target" id="config_8h_1aaadff6355a4e2b6214c3c33ce939c26ba41e5b89d1a50947a93b2616935cffa0c"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_RESAMPLER_PROFILE_DEFAULT</span></span></span><a class="headerlink" href="#c.roc_resampler_profile.ROC_RESAMPLER_PROFILE_DEFAULT" title="Link to this definition">¶</a><br /></dt>
<dd><p>Default profile. </p>
<p>Current default is <code class="docutils literal notranslate"><span class="pre">ROC_RESAMPLER_PROFILE_MEDIUM</span></code>. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_resampler_profile.ROC_RESAMPLER_PROFILE_HIGH">
<span class="target" id="config_8h_1aaadff6355a4e2b6214c3c33ce939c26baa5da7b1489c73aadee506e8de8e88df9"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_RESAMPLER_PROFILE_HIGH</span></span></span><a class="headerlink" href="#c.roc_resampler_profile.ROC_RESAMPLER_PROFILE_HIGH" title="Link to this definition">¶</a><br /></dt>
<dd><p>High quality, higher CPU usage. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_resampler_profile.ROC_RESAMPLER_PROFILE_MEDIUM">
<span class="target" id="config_8h_1aaadff6355a4e2b6214c3c33ce939c26bae80836245a330153ec01e7480c2b0189"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_RESAMPLER_PROFILE_MEDIUM</span></span></span><a class="headerlink" href="#c.roc_resampler_profile.ROC_RESAMPLER_PROFILE_MEDIUM" title="Link to this definition">¶</a><br /></dt>
<dd><p>Medium quality, medium CPU usage. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_resampler_profile.ROC_RESAMPLER_PROFILE_LOW">
<span class="target" id="config_8h_1aaadff6355a4e2b6214c3c33ce939c26ba5a77c1cdb31f2911bbe660331ce68d9c"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_RESAMPLER_PROFILE_LOW</span></span></span><a class="headerlink" href="#c.roc_resampler_profile.ROC_RESAMPLER_PROFILE_LOW" title="Link to this definition">¶</a><br /></dt>
<dd><p>Low quality, lower CPU usage. </p>
</dd></dl>

</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.roc_context_config">
<span class="target" id="structroc__context__config"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_context_config</span></span></span><a class="headerlink" href="#c.roc_context_config" title="Link to this definition">¶</a><br /></dt>
<dd><p>Context configuration. </p>
<p>It is safe to memset() this struct with zeros to get a default config. It is also safe to memcpy() this struct to get a copy of config.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#context_8h_1a854f5a77756c8c473fef82d13b1e470f"><span class="std std-ref">roc_context</span></a></p>
</div>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.roc_context_config.max_packet_size">
<span class="target" id="structroc__context__config_1af4f8231811e2b8159bf1a66687d15658"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">max_packet_size</span></span></span><a class="headerlink" href="#c.roc_context_config.max_packet_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>Maximum size in bytes of a network packet. </p>
<p>Defines the amount of bytes allocated per network packet. Sender and receiver won’t handle packets larger than this. If zero, default value is used. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_context_config.max_frame_size">
<span class="target" id="structroc__context__config_1ab837945349c0ae288863a8c865a52f80"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">max_frame_size</span></span></span><a class="headerlink" href="#c.roc_context_config.max_frame_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>Maximum size in bytes of an audio frame. </p>
<p>Defines the amount of bytes allocated per intermediate internal frame in the pipeline. Does not limit the size of the frames provided by user. If zero, default value is used. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.roc_sender_config">
<span class="target" id="structroc__sender__config"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender_config</span></span></span><a class="headerlink" href="#c.roc_sender_config" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sender configuration. </p>
<p>For most fields, zero value means “use default”, and you can memset() this struct with zeros and then set only a few fields that don’t have defaults. It is safe to use memcpy() to get a copy of config, the struct is flat.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sender_8h_1ad2370a2cbe2174fd33a630b08acbc783"><span class="std std-ref">roc_sender</span></a></p>
</div>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.roc_sender_config.frame_encoding">
<span class="target" id="structroc__sender__config_1abc99a06004b44c5930084a81631b1902"></span><a class="reference internal" href="#c.roc_media_encoding" title="roc_media_encoding"><span class="n"><span class="pre">roc_media_encoding</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">frame_encoding</span></span></span><a class="headerlink" href="#c.roc_sender_config.frame_encoding" title="Link to this definition">¶</a><br /></dt>
<dd><p>The encoding used in frames passed to sender. </p>
<p>Frame encoding defines sample format, channel layout, and sample rate in local frames created by user and passed to sender. Should be set (zero value is invalid). </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_sender_config.packet_encoding">
<span class="target" id="structroc__sender__config_1ab46d41c4d6f80f2bb6addbc4b0249e21"></span><a class="reference internal" href="#c.roc_packet_encoding" title="roc_packet_encoding"><span class="n"><span class="pre">roc_packet_encoding</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">packet_encoding</span></span></span><a class="headerlink" href="#c.roc_sender_config.packet_encoding" title="Link to this definition">¶</a><br /></dt>
<dd><p>The encoding used for packets produced by sender. </p>
<p>Packet encoding defines sample format, channel layout, and sample rate in network packets. If packet encoding differs from frame encoding, conversion is performed automatically.</p>
<p>If zero, sender selects packet encoding automatically based on <code class="docutils literal notranslate"><span class="pre">frame_encoding</span></code>. This automatic selection matches only encodings that have exact same sample rate and channel layout, and hence don’t require conversions. If you need conversions, you should set packet encoding explicitly.</p>
<p>If you want to force specific packet encoding, and built-in set of encodings is not enough, you can use <a class="reference internal" href="#context_8h_1a43ff1ec42c996b34af90cf8a9a8b900c"><span class="std std-ref">roc_context_register_encoding()</span></a> to register custom encoding, set <code class="docutils literal notranslate"><span class="pre">packet_encoding</span></code> to registered identifier. If you use signaling protocol like RTSP, it’s enough to register in just on sender; otherwise, you need to do the same on receiver as well. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_sender_config.packet_length">
<span class="target" id="structroc__sender__config_1a4b096f5c8d71aa0aba023c387c77eae4"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">packet_length</span></span></span><a class="headerlink" href="#c.roc_sender_config.packet_length" title="Link to this definition">¶</a><br /></dt>
<dd><p>The length of the packets produced by sender, in nanoseconds. </p>
<p>Number of nanoseconds encoded per packet. The samples written to the sender are buffered until the full packet is accumulated or the sender is flushed or closed. Larger number reduces packet overhead but also increases latency. If zero, default value is used. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_sender_config.packet_interleaving">
<span class="target" id="structroc__sender__config_1a3cf4d1ccd6c32b023b1db28dac41dc58"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">packet_interleaving</span></span></span><a class="headerlink" href="#c.roc_sender_config.packet_interleaving" title="Link to this definition">¶</a><br /></dt>
<dd><p>Enable packet interleaving. </p>
<p>If non-zero, the sender shuffles packets before sending them. This may increase robustness but also increases latency. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_sender_config.fec_encoding">
<span class="target" id="structroc__sender__config_1aef252ca68ebd5381a11ee5b3af80e72c"></span><a class="reference internal" href="#c.roc_fec_encoding" title="roc_fec_encoding"><span class="n"><span class="pre">roc_fec_encoding</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fec_encoding</span></span></span><a class="headerlink" href="#c.roc_sender_config.fec_encoding" title="Link to this definition">¶</a><br /></dt>
<dd><p>FEC encoding to use. </p>
<p>If non-zero, the sender employs a FEC encoding to generate redundant packets which may be used on receiver to restore lost packets. This requires both sender and receiver to use two separate source and repair endpoints. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_sender_config.fec_block_source_packets">
<span class="target" id="structroc__sender__config_1a3289e005e4bfbb3948e55cfd19e707a5"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fec_block_source_packets</span></span></span><a class="headerlink" href="#c.roc_sender_config.fec_block_source_packets" title="Link to this definition">¶</a><br /></dt>
<dd><p>Number of source packets per FEC block. </p>
<p>Used if some FEC encoding is selected.</p>
<p>Sender divides stream into blocks of N source (media) packets, and adds M repair (redundancy) packets to each block, where N is <code class="docutils literal notranslate"><span class="pre">fec_block_source_packets</span></code> and M is <code class="docutils literal notranslate"><span class="pre">fec_block_repair_packets</span></code>.</p>
<p>Larger number of source packets in block increases robustness (repair ratio), but also increases latency.</p>
<p>If zero, default value is used. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_sender_config.fec_block_repair_packets">
<span class="target" id="structroc__sender__config_1a1b0acc0afb370f055a239bf9ea9a763b"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fec_block_repair_packets</span></span></span><a class="headerlink" href="#c.roc_sender_config.fec_block_repair_packets" title="Link to this definition">¶</a><br /></dt>
<dd><p>Number of repair packets per FEC block. </p>
<p>Used if some FEC encoding is selected.</p>
<p>Sender divides stream into blocks of N source (media) packets, and adds M repair (redundancy) packets to each block, where N is <code class="docutils literal notranslate"><span class="pre">fec_block_source_packets</span></code> and M is <code class="docutils literal notranslate"><span class="pre">fec_block_repair_packets</span></code>.</p>
<p>Larger number of repair packets in block increases robustness (repair ratio), but also increases traffic. Number of repair packets usually should be 1/2 or 2/3 of the number of source packets.</p>
<p>If zero, default value is used. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_sender_config.clock_source">
<span class="target" id="structroc__sender__config_1af9604730c8faebcc47f166f7347759e3"></span><a class="reference internal" href="#c.roc_clock_source" title="roc_clock_source"><span class="n"><span class="pre">roc_clock_source</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clock_source</span></span></span><a class="headerlink" href="#c.roc_sender_config.clock_source" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clock source to use. </p>
<p>Defines whether write operation will be blocking or non-blocking. If zero, default value is used (<code class="docutils literal notranslate"><span class="pre">ROC_CLOCK_SOURCE_EXTERNAL</span></code>). </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_sender_config.resampler_backend">
<span class="target" id="structroc__sender__config_1a25efffc1d18614a994c8ad6968ab7b53"></span><a class="reference internal" href="#c.roc_resampler_backend" title="roc_resampler_backend"><span class="n"><span class="pre">roc_resampler_backend</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">resampler_backend</span></span></span><a class="headerlink" href="#c.roc_sender_config.resampler_backend" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resampler backend to use. </p>
<p>If zero, default value is used. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_sender_config.resampler_profile">
<span class="target" id="structroc__sender__config_1a58026dab2037cf92ed8a3d25326b62ff"></span><a class="reference internal" href="#c.roc_resampler_profile" title="roc_resampler_profile"><span class="n"><span class="pre">roc_resampler_profile</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">resampler_profile</span></span></span><a class="headerlink" href="#c.roc_sender_config.resampler_profile" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resampler profile to use. </p>
<p>If non-zero, the sender employs resampler if the frame sample rate differs from the packet sample rate. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.roc_receiver_config">
<span class="target" id="structroc__receiver__config"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver_config</span></span></span><a class="headerlink" href="#c.roc_receiver_config" title="Link to this definition">¶</a><br /></dt>
<dd><p>Receiver configuration. </p>
<p>For most fields, zero value means “use default”, and you can memset() this struct with zeros and then set only a few fields that don’t have defaults. It is safe to use memcpy() to get a copy of config, the struct is flat.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#receiver_8h_1ade93cec525bde9a255df34d85eb70280"><span class="std std-ref">roc_receiver</span></a></p>
</div>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.roc_receiver_config.frame_encoding">
<span class="target" id="structroc__receiver__config_1a18d43d53f7b0ce0cf1570d9f74fc81f9"></span><a class="reference internal" href="#c.roc_media_encoding" title="roc_media_encoding"><span class="n"><span class="pre">roc_media_encoding</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">frame_encoding</span></span></span><a class="headerlink" href="#c.roc_receiver_config.frame_encoding" title="Link to this definition">¶</a><br /></dt>
<dd><p>The encoding used in frames returned by receiver. </p>
<p>Frame encoding defines sample format, channel layout, and sample rate in local frames returned by receiver to user. Should be set (zero value is invalid). </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_receiver_config.clock_source">
<span class="target" id="structroc__receiver__config_1a495a4b048fc5e8eb2ed01ef21f1dd4b7"></span><a class="reference internal" href="#c.roc_clock_source" title="roc_clock_source"><span class="n"><span class="pre">roc_clock_source</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clock_source</span></span></span><a class="headerlink" href="#c.roc_receiver_config.clock_source" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clock source. </p>
<p>Defines whether read operation will be blocking or non-blocking. If zero, <a class="reference internal" href="#config_8h_1add917f6cbdc964eb7a42f47769bc2407ac4b026fb3476ce4fed4f946c3fc9fd7a"><span class="std std-ref">ROC_CLOCK_SOURCE_EXTERNAL</span></a> is used. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_receiver_config.clock_sync_backend">
<span class="target" id="structroc__receiver__config_1af529e511445d6c3b1c1d8de8ef4732a8"></span><a class="reference internal" href="#c.roc_clock_sync_backend" title="roc_clock_sync_backend"><span class="n"><span class="pre">roc_clock_sync_backend</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clock_sync_backend</span></span></span><a class="headerlink" href="#c.roc_receiver_config.clock_sync_backend" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clock synchronization backend. </p>
<p>Defines how sender and receiver clocks are synchronized. If zero, default value is used. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_receiver_config.clock_sync_profile">
<span class="target" id="structroc__receiver__config_1adeef4e79312d574b30bcce86f0c9235e"></span><a class="reference internal" href="#c.roc_clock_sync_profile" title="roc_clock_sync_profile"><span class="n"><span class="pre">roc_clock_sync_profile</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clock_sync_profile</span></span></span><a class="headerlink" href="#c.roc_receiver_config.clock_sync_profile" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clock synchronization profile. </p>
<p>Defines what latency and network jitter are tolerated. If zero, default value is used. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_receiver_config.resampler_backend">
<span class="target" id="structroc__receiver__config_1a56cf4a19fe3cbfd553ea0685500c7ba6"></span><a class="reference internal" href="#c.roc_resampler_backend" title="roc_resampler_backend"><span class="n"><span class="pre">roc_resampler_backend</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">resampler_backend</span></span></span><a class="headerlink" href="#c.roc_receiver_config.resampler_backend" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resampler backend. </p>
<p>Affects CPU usage, quality, and clock synchronization precision. If zero, default value is used. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_receiver_config.resampler_profile">
<span class="target" id="structroc__receiver__config_1a38d6e3de9ae936fd2b6b437db3384bc9"></span><a class="reference internal" href="#c.roc_resampler_profile" title="roc_resampler_profile"><span class="n"><span class="pre">roc_resampler_profile</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">resampler_profile</span></span></span><a class="headerlink" href="#c.roc_receiver_config.resampler_profile" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resampler profile. </p>
<p>Affects CPU usage and quality. If zero, default value is used. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_receiver_config.target_latency">
<span class="target" id="structroc__receiver__config_1af7e450a7a5e282bcb4de2f527027afbe"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">target_latency</span></span></span><a class="headerlink" href="#c.roc_receiver_config.target_latency" title="Link to this definition">¶</a><br /></dt>
<dd><p>Target latency, in nanoseconds. </p>
<p>The session will not start playing until it accumulates the requested latency. Then, if clock synchronization is enabled, the session will adjust its clock to keep actual latency as close as possible to the target latency. If zero, default value is used. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_receiver_config.latency_tolerance">
<span class="target" id="structroc__receiver__config_1a5b03f6a3f15e805b739140b652ff026f"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">latency_tolerance</span></span></span><a class="headerlink" href="#c.roc_receiver_config.latency_tolerance" title="Link to this definition">¶</a><br /></dt>
<dd><p>Maximum allowed delta between current and target latency, in nanoseconds. </p>
<p>If session latency differs from the target latency by more than given value, the session is terminated (it can then automatically restart). Receiver itself is not terminated; if there are no sessions, it will produce zeros. If zero, default value is used. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_receiver_config.no_playback_timeout">
<span class="target" id="structroc__receiver__config_1a63901e448e3a54e95ccdce9b9a49e7e2"></span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">no_playback_timeout</span></span></span><a class="headerlink" href="#c.roc_receiver_config.no_playback_timeout" title="Link to this definition">¶</a><br /></dt>
<dd><p>Timeout for the lack of playback, in nanoseconds. </p>
<p>If there is no playback during this period, the session is terminated (it can then automatically restart). Receiver itself is not terminated; if there are no sessions, it will produce zeros. This mechanism allows to detect dead, hanging, or incompatible clients that generate unparseable packets. If zero, default value is used. If negative, the timeout is disabled. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_receiver_config.choppy_playback_timeout">
<span class="target" id="structroc__receiver__config_1a03d8b3503230436b785cc1f6ec9e182c"></span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">choppy_playback_timeout</span></span></span><a class="headerlink" href="#c.roc_receiver_config.choppy_playback_timeout" title="Link to this definition">¶</a><br /></dt>
<dd><p>Timeout for choppy playback, in nanoseconds. </p>
<p>If there is constant stuttering during this period, the session is terminated (it can then automatically restart). Receiver itself is not terminated; if there are no sessions, it will produce zeros. This mechanism allows to detect situations when playback continues but there are frequent glitches, for example because there is a high ratio of late packets. If zero, default value is used. If negative, the timeout is disabled. </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="roc-metrics">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">roc_metrics</a><a class="headerlink" href="#roc-metrics" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;roc/metrics.h&gt;</span>
</pre></div>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.roc_sender_metrics">
<span class="target" id="structroc__sender__metrics"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_sender_metrics</span></span></span><a class="headerlink" href="#c.roc_sender_metrics" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sender slot metrics. </p>
<p>Represents metrics of single sender slot. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.roc_sender_metrics.unused">
<span class="target" id="structroc__sender__metrics_1ae0075d8abe83a46a2af4a2b71ee4ca21"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">unused</span></span></span><a class="headerlink" href="#c.roc_sender_metrics.unused" title="Link to this definition">¶</a><br /></dt>
<dd><p>Do not use. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.roc_receiver_metrics">
<span class="target" id="structroc__receiver__metrics"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_receiver_metrics</span></span></span><a class="headerlink" href="#c.roc_receiver_metrics" title="Link to this definition">¶</a><br /></dt>
<dd><p>Receiver slot metrics. </p>
<p>Represents metrics of single receiver slot. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.roc_receiver_metrics.num_sessions">
<span class="target" id="structroc__receiver__metrics_1a496dfd737de235057e91ab4528740420"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">num_sessions</span></span></span><a class="headerlink" href="#c.roc_receiver_metrics.num_sessions" title="Link to this definition">¶</a><br /></dt>
<dd><p>Number of sessions connected to receiver slot. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_receiver_metrics.sessions">
<span class="target" id="structroc__receiver__metrics_1a09a84ea97e235301903330c3c34d0720"></span><a class="reference internal" href="#c.roc_session_metrics" title="roc_session_metrics"><span class="n"><span class="pre">roc_session_metrics</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">sessions</span></span></span><a class="headerlink" href="#c.roc_receiver_metrics.sessions" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pointer to user-defined buffer for session metrics. </p>
<p>If user sets this pointer, it is used to write metrics for individual sessions. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_receiver_metrics.sessions_size">
<span class="target" id="structroc__receiver__metrics_1a3aca33cab7cbc729dd4eebb327c2346c"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sessions_size</span></span></span><a class="headerlink" href="#c.roc_receiver_metrics.sessions_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>Number of structs in session metrics buffer. </p>
<p>If <code class="docutils literal notranslate"><span class="pre">sessions</span></code> pointer is set, <code class="docutils literal notranslate"><span class="pre">sessions_size</span></code> should define its size. If number of sessions is greater than provided size, only metrics for first <code class="docutils literal notranslate"><span class="pre">sessions_size</span></code> sessions will be written. Total number of sessions is always written to <code class="docutils literal notranslate"><span class="pre">num_sessions</span></code>. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.roc_session_metrics">
<span class="target" id="structroc__session__metrics"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_session_metrics</span></span></span><a class="headerlink" href="#c.roc_session_metrics" title="Link to this definition">¶</a><br /></dt>
<dd><p>Receiver session metrics. </p>
<p>Represents metrics of single session connected to receiver. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.roc_session_metrics.niq_latency">
<span class="target" id="structroc__session__metrics_1a6ebd9745289b4359c85f5eee14b45e27"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">niq_latency</span></span></span><a class="headerlink" href="#c.roc_session_metrics.niq_latency" title="Link to this definition">¶</a><br /></dt>
<dd><p>Estimated network-incoming-queue latency, in nanoseconds. </p>
<p>Defines how much media is buffered in receiver packet queue. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_session_metrics.e2e_latency">
<span class="target" id="structroc__session__metrics_1a9c944f71215a2d9531527f29b3bc77a3"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">e2e_latency</span></span></span><a class="headerlink" href="#c.roc_session_metrics.e2e_latency" title="Link to this definition">¶</a><br /></dt>
<dd><p>Estimated end-to-end latency, in nanoseconds. </p>
<p>Defines how much time passes after frame is written to sender and before it is read from receiver.</p>
<p>Computations are based on RTCP and NTP. If <a class="reference internal" href="#config_8h_1a89697f253e0644d6f738fecca34a2516afcf3067776b830835da275d3265be63b"><span class="std std-ref">ROC_PROTO_RTCP</span></a> is not used, latency will be zero. If NTP clocks of sender and receiver are not synchronized, latency will be calculated incorrectly.</p>
<p>May be zero initially until enough data is transferred. </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="roc-log">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">roc_log</a><a class="headerlink" href="#roc-log" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;roc/log.h&gt;</span>
</pre></div>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.roc_log_level">
<span class="target" id="log_8h_1ab2fb2cdf9c3f531d537537cbd7323616"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_log_level</span></span></span><a class="headerlink" href="#c.roc_log_level" title="Link to this definition">¶</a><br /></dt>
<dd><p>Log level. </p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#log_8h_1abee413e54d258026cd1e534e855f866d"><span class="std std-ref">roc_log_set_level</span></a></p>
</div>
</p>
<p><em>Values:</em></p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_log_level.ROC_LOG_NONE">
<span class="target" id="log_8h_1ab2fb2cdf9c3f531d537537cbd7323616a84812ee2083bf4949216d0ce6a492a57"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_LOG_NONE</span></span></span><a class="headerlink" href="#c.roc_log_level.ROC_LOG_NONE" title="Link to this definition">¶</a><br /></dt>
<dd><p>No messages. </p>
<p>Setting this level disables logging completely. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_log_level.ROC_LOG_ERROR">
<span class="target" id="log_8h_1ab2fb2cdf9c3f531d537537cbd7323616ab79f5a13b5cff90f5e1b259d2e1ab484"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_LOG_ERROR</span></span></span><a class="headerlink" href="#c.roc_log_level.ROC_LOG_ERROR" title="Link to this definition">¶</a><br /></dt>
<dd><p>Error messages. </p>
<p>Setting this level enables logging only when something goes wrong, e.g. a user operation can’t be completed, or there is not enough memory for a new session. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_log_level.ROC_LOG_INFO">
<span class="target" id="log_8h_1ab2fb2cdf9c3f531d537537cbd7323616ab6caaa36c65c4eb2e3da3e709251c4bb"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_LOG_INFO</span></span></span><a class="headerlink" href="#c.roc_log_level.ROC_LOG_INFO" title="Link to this definition">¶</a><br /></dt>
<dd><p>Informational messages. </p>
<p>Setting this level enables logging of important high-level events, like binding a new port or creating a new session. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_log_level.ROC_LOG_DEBUG">
<span class="target" id="log_8h_1ab2fb2cdf9c3f531d537537cbd7323616afd124195c6a7601a1799bc33e5427c95"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_LOG_DEBUG</span></span></span><a class="headerlink" href="#c.roc_log_level.ROC_LOG_DEBUG" title="Link to this definition">¶</a><br /></dt>
<dd><p>Debug messages. </p>
<p>Setting this level enables logging of debug messages. Doesn’t affect performance. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.roc_log_level.ROC_LOG_TRACE">
<span class="target" id="log_8h_1ab2fb2cdf9c3f531d537537cbd7323616a10d2fd875d510db6369f70313ff93846"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ROC_LOG_TRACE</span></span></span><a class="headerlink" href="#c.roc_log_level.ROC_LOG_TRACE" title="Link to this definition">¶</a><br /></dt>
<dd><p>Debug messages (extra verbosity). </p>
<p>Setting this level enables verbose tracing. May cause significant slow down. </p>
</dd></dl>

</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.roc_log_message">
<span class="target" id="structroc__log__message"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_log_message</span></span></span><a class="headerlink" href="#c.roc_log_message" title="Link to this definition">¶</a><br /></dt>
<dd><p>Log message. </p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#log_8h_1ac47b8e2ceb7a7f8d78adc7952916f6e5"><span class="std std-ref">roc_log_set_handler</span></a></p>
</div>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.roc_log_message.level">
<span class="target" id="structroc__log__message_1a3b42929b0068795eb4c2d45fb6979d60"></span><a class="reference internal" href="#c.roc_log_level" title="roc_log_level"><span class="n"><span class="pre">roc_log_level</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">level</span></span></span><a class="headerlink" href="#c.roc_log_message.level" title="Link to this definition">¶</a><br /></dt>
<dd><p>Message log level. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_log_message.module">
<span class="target" id="structroc__log__message_1a70f93921cbe8449ddf6f34d534694991"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">module</span></span></span><a class="headerlink" href="#c.roc_log_message.module" title="Link to this definition">¶</a><br /></dt>
<dd><p>Name of the module that originated the message. </p>
<p>Pointer can be used only until <a class="reference internal" href="#log_8h_1acef60730d92fda5713281b58b17c62af"><span class="std std-ref">roc_log_handler()</span></a> returns. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_log_message.file">
<span class="target" id="structroc__log__message_1ac768abaa9bc988485d5a22eaa3c4f9c7"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">file</span></span></span><a class="headerlink" href="#c.roc_log_message.file" title="Link to this definition">¶</a><br /></dt>
<dd><p>Name of the source code file. </p>
<p>May be NULL. Pointer can be used only until <a class="reference internal" href="#log_8h_1acef60730d92fda5713281b58b17c62af"><span class="std std-ref">roc_log_handler()</span></a> returns. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_log_message.line">
<span class="target" id="structroc__log__message_1af832df327e0054cc0d3d785094930659"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">line</span></span></span><a class="headerlink" href="#c.roc_log_message.line" title="Link to this definition">¶</a><br /></dt>
<dd><p>Line number in the source code file. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_log_message.time">
<span class="target" id="structroc__log__message_1addce7600b954d96b7ed7472b4c40e50d"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">time</span></span></span><a class="headerlink" href="#c.roc_log_message.time" title="Link to this definition">¶</a><br /></dt>
<dd><p>Message timestamp, nanoseconds since Unix epoch. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_log_message.pid">
<span class="target" id="structroc__log__message_1aceec299516f13e7814ebb58b1ae14953"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pid</span></span></span><a class="headerlink" href="#c.roc_log_message.pid" title="Link to this definition">¶</a><br /></dt>
<dd><p>Platform-specific process ID. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_log_message.tid">
<span class="target" id="structroc__log__message_1ab1cab2028e22b15cdef015bf0f921dbd"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tid</span></span></span><a class="headerlink" href="#c.roc_log_message.tid" title="Link to this definition">¶</a><br /></dt>
<dd><p>Platform-specific thread ID. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_log_message.text">
<span class="target" id="structroc__log__message_1aefa5ab5bc73a3603833196fd77a8de96"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">text</span></span></span><a class="headerlink" href="#c.roc_log_message.text" title="Link to this definition">¶</a><br /></dt>
<dd><p>Message text. </p>
<p>Pointer can be used only until <a class="reference internal" href="#log_8h_1acef60730d92fda5713281b58b17c62af"><span class="std std-ref">roc_log_handler()</span></a> returns. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.roc_log_handler">
<span class="target" id="log_8h_1acef60730d92fda5713281b58b17c62af"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">roc_log_handler</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.roc_log_message" title="roc_log_message"><span class="n"><span class="pre">roc_log_message</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">message</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">argument</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#c.roc_log_handler" title="Link to this definition">¶</a><br /></dt>
<dd><p>Log handler. </p>
<p><strong>Parameters</strong><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">message</span></code> define message to be logged</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">argument</span></code> is the argument passed to roc_log_set_handler</p></li>
</ul>
</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#log_8h_1ac47b8e2ceb7a7f8d78adc7952916f6e5"><span class="std std-ref">roc_log_set_handler</span></a></p>
</div>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_log_set_level">
<span class="target" id="log_8h_1abee413e54d258026cd1e534e855f866d"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_log_set_level</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_log_level" title="roc_log_level"><span class="n"><span class="pre">roc_log_level</span></span></a><span class="w"> </span><span class="n"><span class="pre">level</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_log_set_level" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set maximum log level. </p>
<p>Messages with log levels higher than <code class="docutils literal notranslate"><span class="pre">level</span></code> will be dropped. By default the log level is set to <a class="reference internal" href="#log_8h_1ab2fb2cdf9c3f531d537537cbd7323616ab79f5a13b5cff90f5e1b259d2e1ab484"><span class="std std-ref">ROC_LOG_ERROR</span></a>.</p>
<p><strong>Thread safety</strong></p>
<p>Can be used concurrently. </p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_log_set_handler">
<span class="target" id="log_8h_1ac47b8e2ceb7a7f8d78adc7952916f6e5"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_log_set_handler</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_log_handler" title="roc_log_handler"><span class="n"><span class="pre">roc_log_handler</span></span></a><span class="w"> </span><span class="n"><span class="pre">handler</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">argument</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_log_set_handler" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set log handler. </p>
<p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> is not NULL, messages are passed to the handler. Otherwise, messages are printed to stderr. By default the log handler is set to NULL.</p>
<p><code class="docutils literal notranslate"><span class="pre">argument</span></code> will be passed to the handler each time it is invoked.</p>
<p>It’s guaranteed that the previously set handler, if any, will not be used after this function returns.</p>
<p><strong>Thread safety</strong></p>
<p>Can be used concurrently. Handler calls are serialized, so the handler itself doesn’t need to be thread-safe. </p>
</dd></dl>

</section>
<section id="roc-version">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">roc_version</a><a class="headerlink" href="#roc-version" title="Link to this heading">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;roc/version.h&gt;</span>
</pre></div>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.ROC_VERSION_MAJOR">
<span class="target" id="version_8h_1a4f73ff3bae19e0c2bf1874a6efbf237a"></span><span class="sig-name descname"><span class="n"><span class="pre">ROC_VERSION_MAJOR</span></span></span><a class="headerlink" href="#c.ROC_VERSION_MAJOR" title="Link to this definition">¶</a><br /></dt>
<dd><p>Major version component. </p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.ROC_VERSION_MINOR">
<span class="target" id="version_8h_1af059c57f5876d115e0e727dcf594f6c4"></span><span class="sig-name descname"><span class="n"><span class="pre">ROC_VERSION_MINOR</span></span></span><a class="headerlink" href="#c.ROC_VERSION_MINOR" title="Link to this definition">¶</a><br /></dt>
<dd><p>Minor version component. </p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.ROC_VERSION_PATCH">
<span class="target" id="version_8h_1a9941aec76e981607d4f181fdb890f78b"></span><span class="sig-name descname"><span class="n"><span class="pre">ROC_VERSION_PATCH</span></span></span><a class="headerlink" href="#c.ROC_VERSION_PATCH" title="Link to this definition">¶</a><br /></dt>
<dd><p>Patch version component. </p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.ROC_VERSION">
<span class="target" id="version_8h_1a9bfa974f7a217ff30ad2726b89648948"></span><span class="sig-name descname"><span class="n"><span class="pre">ROC_VERSION</span></span></span><a class="headerlink" href="#c.ROC_VERSION" title="Link to this definition">¶</a><br /></dt>
<dd><p>Numeric version code. </p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#version_8h_1ab89ca8c834bfb9f17119388bc6bd1c87"><span class="std std-ref">ROC_VERSION_CODE</span></a></p>
</div>
</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.ROC_VERSION_CODE">
<span class="target" id="version_8h_1ab89ca8c834bfb9f17119388bc6bd1c87"></span><span class="sig-name descname"><span class="n"><span class="pre">ROC_VERSION_CODE</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">major</span></span>, <span class="n"><span class="pre">minor</span></span>, <span class="n"><span class="pre">patch</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ROC_VERSION_CODE" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert version triple to numeric version code. </p>
<p>Version codes can be compared direcrly, e.g.: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#if ROC_VERSION &lt; ROC_VERSION_CODE(1, 2, 3)</span>
<span class="o">...</span>
<span class="c1">#endif</span>
</pre></div>
</div>
</p>
</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.roc_version">
<span class="target" id="structroc__version"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_version</span></span></span><a class="headerlink" href="#c.roc_version" title="Link to this definition">¶</a><br /></dt>
<dd><p>Version components. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.roc_version.major">
<span class="target" id="structroc__version_1a44a472de4ca0ec038b66dcd98ed76a4f"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">major</span></span></span><a class="headerlink" href="#c.roc_version.major" title="Link to this definition">¶</a><br /></dt>
<dd><p>Major version component. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_version.minor">
<span class="target" id="structroc__version_1a006d1efa5ee3db0e73aef335fa587a9b"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">minor</span></span></span><a class="headerlink" href="#c.roc_version.minor" title="Link to this definition">¶</a><br /></dt>
<dd><p>Minor version component. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_version.patch">
<span class="target" id="structroc__version_1a82a458dbac2cdd0ebddb50518b5fda14"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">patch</span></span></span><a class="headerlink" href="#c.roc_version.patch" title="Link to this definition">¶</a><br /></dt>
<dd><p>Patch version component. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.roc_version.code">
<span class="target" id="structroc__version_1ad89946741fee20d501cc3912e3484be2"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">code</span></span></span><a class="headerlink" href="#c.roc_version.code" title="Link to this definition">¶</a><br /></dt>
<dd><p>Numeric version code. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.roc_version_get">
<span class="target" id="version_8h_1ad11bf8e9d60bc3f8b845319535c6a4b8"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">roc_version_get</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.roc_version" title="roc_version"><span class="n"><span class="pre">roc_version</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">version</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.roc_version_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>Retrieve version numbers. </p>
<p>This function can be used to retrieve actual run-time version of the library. It may be different from the compile-time version when using shared library. </p>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo80.png" alt="Logo"/>
            </a></p>
<h3><a href="../index.html">Table of Contents</a></h3>
<p class="caption" role="heading"><span class="caption-text">Table of Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../about_project.html">About project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../building.html">Building</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">API</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">Bindings</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tools.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../manuals.html">Manuals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../portability.html">Portability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../internals.html">Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development.html">Development</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="examples.html" title="Examples"
             >next</a> |</li>
        <li class="right" >
          <a href="../api.html" title="API"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Roc Toolkit 0.3.0</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../api.html" >API</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Reference</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Roc Streaming authors.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>