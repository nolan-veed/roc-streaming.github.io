<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Roc Toolkit internal modules: roc::ctl::ControlTaskQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script src="/analytics.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon80.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Roc Toolkit internal modules
   </div>
   <div id="projectbrief">Roc Toolkit: real-time audio streaming</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classroc_1_1ctl_1_1ControlTaskQueue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classroc_1_1ctl_1_1ControlTaskQueue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">roc::ctl::ControlTaskQueue Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Control task queue.  
 <a href="classroc_1_1ctl_1_1ControlTaskQueue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="control__task__queue_8h_source.html">control_task_queue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for roc::ctl::ControlTaskQueue:</div>
<div class="dyncontent">
<div class="center"><img src="classroc_1_1ctl_1_1ControlTaskQueue__inherit__graph.png" border="0" usemap="#aroc_1_1ctl_1_1ControlTaskQueue_inherit__map" alt="Inheritance graph"/></div>
<map name="aroc_1_1ctl_1_1ControlTaskQueue_inherit__map" id="aroc_1_1ctl_1_1ControlTaskQueue_inherit__map">
<area shape="rect" title="Control task queue." alt="" coords="5,169,197,196"/>
<area shape="rect" href="classroc_1_1core_1_1Thread.html" title="Base class for thread objects." alt="" coords="36,95,167,121"/>
<area shape="rect" href="classroc_1_1core_1_1NonCopyable.html" title=" " alt="" coords="15,5,188,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for roc::ctl::ControlTaskQueue:</div>
<div class="dyncontent">
<div class="center"><img src="classroc_1_1ctl_1_1ControlTaskQueue__coll__graph.png" border="0" usemap="#aroc_1_1ctl_1_1ControlTaskQueue_coll__map" alt="Collaboration graph"/></div>
<map name="aroc_1_1ctl_1_1ControlTaskQueue_coll__map" id="aroc_1_1ctl_1_1ControlTaskQueue_coll__map">
<area shape="rect" title="Control task queue." alt="" coords="5,169,197,196"/>
<area shape="rect" href="classroc_1_1core_1_1Thread.html" title="Base class for thread objects." alt="" coords="36,95,167,121"/>
<area shape="rect" href="classroc_1_1core_1_1NonCopyable.html" title=" " alt="" coords="15,5,188,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae68b25dd21f14a1171b041e83c0e9eda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroc_1_1ctl_1_1ControlTaskQueue.html#ae68b25dd21f14a1171b041e83c0e9eda">ControlTaskQueue</a> ()</td></tr>
<tr class="memdesc:ae68b25dd21f14a1171b041e83c0e9eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize.  <a href="classroc_1_1ctl_1_1ControlTaskQueue.html#ae68b25dd21f14a1171b041e83c0e9eda">More...</a><br /></td></tr>
<tr class="separator:ae68b25dd21f14a1171b041e83c0e9eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8d284781e63d54c498b4be6f0a0b73"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroc_1_1ctl_1_1ControlTaskQueue.html#a9d8d284781e63d54c498b4be6f0a0b73">~ControlTaskQueue</a> ()</td></tr>
<tr class="memdesc:a9d8d284781e63d54c498b4be6f0a0b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy.  <a href="classroc_1_1ctl_1_1ControlTaskQueue.html#a9d8d284781e63d54c498b4be6f0a0b73">More...</a><br /></td></tr>
<tr class="separator:a9d8d284781e63d54c498b4be6f0a0b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbedc10ce8b178d18b2723bcbbae84f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroc_1_1ctl_1_1ControlTaskQueue.html#acdbedc10ce8b178d18b2723bcbbae84f">is_valid</a> () const</td></tr>
<tr class="memdesc:acdbedc10ce8b178d18b2723bcbbae84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the object was successfully constructed.  <a href="classroc_1_1ctl_1_1ControlTaskQueue.html#acdbedc10ce8b178d18b2723bcbbae84f">More...</a><br /></td></tr>
<tr class="separator:acdbedc10ce8b178d18b2723bcbbae84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b8429dce89f36b9616412158eecd8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroc_1_1ctl_1_1ControlTaskQueue.html#a82b8429dce89f36b9616412158eecd8f">schedule</a> (<a class="el" href="classroc_1_1ctl_1_1ControlTask.html">ControlTask</a> &amp;task, <a class="el" href="classroc_1_1ctl_1_1IControlTaskExecutor.html">IControlTaskExecutor</a> &amp;executor, <a class="el" href="classroc_1_1ctl_1_1IControlTaskCompleter.html">IControlTaskCompleter</a> *completer)</td></tr>
<tr class="memdesc:a82b8429dce89f36b9616412158eecd8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a task for asynchronous execution as soon as possible.  <a href="classroc_1_1ctl_1_1ControlTaskQueue.html#a82b8429dce89f36b9616412158eecd8f">More...</a><br /></td></tr>
<tr class="separator:a82b8429dce89f36b9616412158eecd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38e6e225ed061079c8e6301b42226fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroc_1_1ctl_1_1ControlTaskQueue.html#af38e6e225ed061079c8e6301b42226fe">schedule_at</a> (<a class="el" href="classroc_1_1ctl_1_1ControlTask.html">ControlTask</a> &amp;task, <a class="el" href="namespaceroc_1_1core.html#ae97845bc2af55cb259b19da6a128d409">core::nanoseconds_t</a> deadline, <a class="el" href="classroc_1_1ctl_1_1IControlTaskExecutor.html">IControlTaskExecutor</a> &amp;executor, <a class="el" href="classroc_1_1ctl_1_1IControlTaskCompleter.html">IControlTaskCompleter</a> *completer)</td></tr>
<tr class="memdesc:af38e6e225ed061079c8e6301b42226fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a task for asynchronous execution at given point of time.  <a href="classroc_1_1ctl_1_1ControlTaskQueue.html#af38e6e225ed061079c8e6301b42226fe">More...</a><br /></td></tr>
<tr class="separator:af38e6e225ed061079c8e6301b42226fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7271e924c8d86a87b3faa6418afae1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroc_1_1ctl_1_1ControlTaskQueue.html#a9f7271e924c8d86a87b3faa6418afae1">resume</a> (<a class="el" href="classroc_1_1ctl_1_1ControlTask.html">ControlTask</a> &amp;task)</td></tr>
<tr class="memdesc:a9f7271e924c8d86a87b3faa6418afae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tesume task if it's paused.  <a href="classroc_1_1ctl_1_1ControlTaskQueue.html#a9f7271e924c8d86a87b3faa6418afae1">More...</a><br /></td></tr>
<tr class="separator:a9f7271e924c8d86a87b3faa6418afae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63fc682b475b553ef8c352f492ca931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroc_1_1ctl_1_1ControlTaskQueue.html#ab63fc682b475b553ef8c352f492ca931">async_cancel</a> (<a class="el" href="classroc_1_1ctl_1_1ControlTask.html">ControlTask</a> &amp;task)</td></tr>
<tr class="memdesc:ab63fc682b475b553ef8c352f492ca931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to cancel scheduled task execution, if it's not executed yet.  <a href="classroc_1_1ctl_1_1ControlTaskQueue.html#ab63fc682b475b553ef8c352f492ca931">More...</a><br /></td></tr>
<tr class="separator:ab63fc682b475b553ef8c352f492ca931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238b7163cbfd452f157f96180492196b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroc_1_1ctl_1_1ControlTaskQueue.html#a238b7163cbfd452f157f96180492196b">wait</a> (<a class="el" href="classroc_1_1ctl_1_1ControlTask.html">ControlTask</a> &amp;task)</td></tr>
<tr class="memdesc:a238b7163cbfd452f157f96180492196b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the task is completed.  <a href="classroc_1_1ctl_1_1ControlTaskQueue.html#a238b7163cbfd452f157f96180492196b">More...</a><br /></td></tr>
<tr class="separator:a238b7163cbfd452f157f96180492196b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3437b39e778dfd39743b2c3b26d37a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroc_1_1ctl_1_1ControlTaskQueue.html#afd3437b39e778dfd39743b2c3b26d37a">stop_and_wait</a> ()</td></tr>
<tr class="memdesc:afd3437b39e778dfd39743b2c3b26d37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop thread and wait until it terminates.  <a href="classroc_1_1ctl_1_1ControlTaskQueue.html#afd3437b39e778dfd39743b2c3b26d37a">More...</a><br /></td></tr>
<tr class="separator:afd3437b39e778dfd39743b2c3b26d37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Control task queue. </p>
<p>This class implements a thread-safe task queue, allowing lock-free scheduling of tasks for immediate or delayed execution on the background thread, as well as lock-free task cancellation and re-scheduling (changing deadline).</p>
<p>It also supports tasks to be paused and resumed. Task resuming is lock-free too.</p>
<p>Note that those operations are lock-free only if <a class="el" href="classroc_1_1core_1_1Timer.html#a7ada3d302b2f478599481de8009c2241" title="Set timer deadline. Can be called concurrently, but only one concurrent call will succeed....">core::Timer::try_set_deadline()</a> is so, which however is true on modern platforms.</p>
<p>In the current implementation, priority is given to fast scheduling and cancellation over the strict observance of the scheduling deadlines. In other words, during contention or peak load, scheduling and cancellation will be always fast, but task execution may be delayed.</p>
<p>This design was considered acceptable because the actual users of control task queue are more sensitive to delays than the tasks they schedule. The task queue is used by network and pipeline threads, which should never block and use the task queue to schedule low-priority delayed work.</p>
<p>The implementation uses three queues internally:</p>
<ul>
<li>ready_queue_ - a lock-free queue of tasks of three kinds:<ul>
<li>tasks to be resumed after pause (flags_ &amp; FlagResumed != 0)</li>
<li>tasks to be executed as soon as possible (renewed_deadline_ == 0)</li>
<li>tasks to be re-scheduled with another deadline (renewed_deadline_ &gt; 0)</li>
<li>tasks to be cancelled (renewed_deadline_ &lt; 0)</li>
</ul>
</li>
<li>sleeping_queue_ - a sorted queue of tasks with non-zero deadline, scheduled for execution in future; the task at the head has the smallest (nearest) deadline;</li>
<li>pause_queue_ - an unsorted queue to keep track of all currently paused tasks.</li>
</ul>
<p>task_mutex_ should be acquired to process tasks and/or to access sleeping_queue_ and pause_queue_, as well as non-atomic task fields.</p>
<p>wakeup_timer_ (<a class="el" href="classroc_1_1core_1_1Timer.html" title="Thread-safe timer.">core::Timer</a>) is used to set or wait for the next wakeup time of the background thread. This time is set to zero when ready_queue_ is non-empty, otherwise it is set to the deadline of the first task in sleeping_queue_ if it's non-empty, and otherwise is set to infinity (-1). The timer allows to update the deadline concurrently from any thread.</p>
<p>When the task is scheduled, re-scheduled, or cancelled, there are two ways to complete the operation:</p>
<ul>
<li>If the event loop thread is sleeping and the task_mutex_ is free, we can acquire the mutex and complete the operation in-place by manipulating sleeping_queue_ under the mutex, without bothering event loop thread. This can be done only if we're changing task scheduling and not going to execute it right now.</li>
<li>Otherwise, we push the task to ready_queue_ (which has lock-free push), set the timer wakeup time to zero (to ensure that the event loop thread wont go to sleep), and return, leaving the completion of the operarion to the event loop thread. The event loop thread will fetch the task from ready_queue_ soon and complete the operation by manipulating the sleeping_queue_.</li>
</ul>
<p>The current task state is defined by its atomic field "state_". Various task queue operations move task from one state to another. The move is always performed using atomic CAS or exchange to handle concurrent lock-free updates correctly.</p>
<p>There is also "flags_" field that provides additional information about task that is preserved accross transitions between states; for example that task is being resumed.</p>
<p>Here are some example flows of the task states: </p><div class="fragment"><div class="line"><a class="code" href="classroc_1_1ctl_1_1ControlTaskQueue.html#a82b8429dce89f36b9616412158eecd8f">schedule</a>():</div>
<div class="line">  StateCompleted -&gt; StateReady</div>
<div class="line">    -&gt; StateProcessing -&gt; StateCompleting -&gt; StateCompleted</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classroc_1_1ctl_1_1ControlTaskQueue.html#af38e6e225ed061079c8e6301b42226fe">schedule_at</a>():</div>
<div class="line">  StateCompleted -&gt; StateReady</div>
<div class="line">    -&gt; StateSleeping</div>
<div class="line">    -&gt; StateProcessing -&gt; StateCompleting -&gt; StateCompleted</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classroc_1_1ctl_1_1ControlTaskQueue.html#a9f7271e924c8d86a87b3faa6418afae1">resume</a>():</div>
<div class="line">  StateSleeping -&gt; StateReady</div>
<div class="line">    -&gt; StateProcessing -&gt; StateCompleting -&gt; StateCompleted</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classroc_1_1ctl_1_1ControlTaskQueue.html#ab63fc682b475b553ef8c352f492ca931">async_cancel</a>():</div>
<div class="line">  StateSleeping -&gt; StateReady</div>
<div class="line">    -&gt; StateCancelling -&gt; StateCompleting -&gt; StateCompleted</div>
<div class="ttc" id="aclassroc_1_1ctl_1_1ControlTaskQueue_html_a82b8429dce89f36b9616412158eecd8f"><div class="ttname"><a href="classroc_1_1ctl_1_1ControlTaskQueue.html#a82b8429dce89f36b9616412158eecd8f">roc::ctl::ControlTaskQueue::schedule</a></div><div class="ttdeci">void schedule(ControlTask &amp;task, IControlTaskExecutor &amp;executor, IControlTaskCompleter *completer)</div><div class="ttdoc">Enqueue a task for asynchronous execution as soon as possible.</div></div>
<div class="ttc" id="aclassroc_1_1ctl_1_1ControlTaskQueue_html_a9f7271e924c8d86a87b3faa6418afae1"><div class="ttname"><a href="classroc_1_1ctl_1_1ControlTaskQueue.html#a9f7271e924c8d86a87b3faa6418afae1">roc::ctl::ControlTaskQueue::resume</a></div><div class="ttdeci">void resume(ControlTask &amp;task)</div><div class="ttdoc">Tesume task if it's paused.</div></div>
<div class="ttc" id="aclassroc_1_1ctl_1_1ControlTaskQueue_html_ab63fc682b475b553ef8c352f492ca931"><div class="ttname"><a href="classroc_1_1ctl_1_1ControlTaskQueue.html#ab63fc682b475b553ef8c352f492ca931">roc::ctl::ControlTaskQueue::async_cancel</a></div><div class="ttdeci">void async_cancel(ControlTask &amp;task)</div><div class="ttdoc">Try to cancel scheduled task execution, if it's not executed yet.</div></div>
<div class="ttc" id="aclassroc_1_1ctl_1_1ControlTaskQueue_html_af38e6e225ed061079c8e6301b42226fe"><div class="ttname"><a href="classroc_1_1ctl_1_1ControlTaskQueue.html#af38e6e225ed061079c8e6301b42226fe">roc::ctl::ControlTaskQueue::schedule_at</a></div><div class="ttdeci">void schedule_at(ControlTask &amp;task, core::nanoseconds_t deadline, IControlTaskExecutor &amp;executor, IControlTaskCompleter *completer)</div><div class="ttdoc">Enqueue a task for asynchronous execution at given point of time.</div></div>
</div><!-- fragment --><p>The meaning of the states is the following:</p><ul>
<li>StateReady: task is added to the ready queue for execution or renewal, or probably is currently being renewed in-place</li>
<li>StateSleeping: task renewal is complete and the task was put into the sleeping queue to wait its deadline, or to paused queue to wait resume</li>
<li>StateCancelling: task renewal is complete and the task is being cancelled because it was put to ready queue for cancellation</li>
<li>StateProcessing: task is being processed after fetching it either from ready queue (if it was put there for execution) or sleeping queue</li>
<li>StateCompleting: task processing is complete and the task is being completed</li>
<li>StateCompleted: task is completed and is not used anywhere; it may be safely destroyed or reused; this is also the initial task state </li>
</ul>

<p class="definition">Definition at line <a class="el" href="control__task__queue_8h_source.html#l00125">125</a> of file <a class="el" href="control__task__queue_8h_source.html">control_task_queue.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae68b25dd21f14a1171b041e83c0e9eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68b25dd21f14a1171b041e83c0e9eda">&#9670;&nbsp;</a></span>ControlTaskQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">roc::ctl::ControlTaskQueue::ControlTaskQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Starts background thread. </dd></dl>

</div>
</div>
<a id="a9d8d284781e63d54c498b4be6f0a0b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8d284781e63d54c498b4be6f0a0b73">&#9670;&nbsp;</a></span>~ControlTaskQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual roc::ctl::ControlTaskQueue::~ControlTaskQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy. </p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="classroc_1_1ctl_1_1ControlTaskQueue.html#afd3437b39e778dfd39743b2c3b26d37a" title="Stop thread and wait until it terminates.">stop_and_wait()</a> should be called before destructor. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab63fc682b475b553ef8c352f492ca931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63fc682b475b553ef8c352f492ca931">&#9670;&nbsp;</a></span>async_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void roc::ctl::ControlTaskQueue::async_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroc_1_1ctl_1_1ControlTask.html">ControlTask</a> &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to cancel scheduled task execution, if it's not executed yet. </p>
<ul>
<li>If the task is already completed or is being completed or cancelled, do nothing.</li>
<li>If the task is sleeping or paused, cancel task execution.</li>
<li>If the task is being processed right now (i.e. it's executing or will be executing very soon), then postpone decision until task execution ends. After the task execution, if the task asked to pause or continue, then cancellation request is fulfilled and the task is cancelled; otherwise cancellation request is ignored and the task is completed normally.</li>
</ul>
<p>When the task is being cancelled instead of completed, if it has completer, the completer is invoked. </p>

</div>
</div>
<a id="acdbedc10ce8b178d18b2723bcbbae84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbedc10ce8b178d18b2723bcbbae84f">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool roc::ctl::ControlTaskQueue::is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the object was successfully constructed. </p>

</div>
</div>
<a id="a9f7271e924c8d86a87b3faa6418afae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7271e924c8d86a87b3faa6418afae1">&#9670;&nbsp;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void roc::ctl::ControlTaskQueue::resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroc_1_1ctl_1_1ControlTask.html">ControlTask</a> &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tesume task if it's paused. </p>
<ul>
<li>If the task is paused, schedule it for execution.</li>
<li>If the task is being processed right now (i.e. it's executing or will be executing very soon), then postpone decision until task execution ends. After the task execution, if the task asked to pause, then immediately resume it.</li>
<li>Otherwise, do nothing.</li>
</ul>
<p>If resume is called one or multiple times before task execution, those calls are ignored. Only calls made during or after task execution are honored, and only if the task execution leaved task in paused state.</p>
<p>Subsequent resume calls between task executions are collapsed into one; even if resume was called multiple after task paused and before it's executed again, next pause will need a new resume call. </p>

</div>
</div>
<a id="a82b8429dce89f36b9616412158eecd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b8429dce89f36b9616412158eecd8f">&#9670;&nbsp;</a></span>schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void roc::ctl::ControlTaskQueue::schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroc_1_1ctl_1_1ControlTask.html">ControlTask</a> &amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classroc_1_1ctl_1_1IControlTaskExecutor.html">IControlTaskExecutor</a> &amp;&#160;</td>
          <td class="paramname"><em>executor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classroc_1_1ctl_1_1IControlTaskCompleter.html">IControlTaskCompleter</a> *&#160;</td>
          <td class="paramname"><em>completer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue a task for asynchronous execution as soon as possible. </p>
<p>This is like <a class="el" href="classroc_1_1ctl_1_1ControlTaskQueue.html#af38e6e225ed061079c8e6301b42226fe" title="Enqueue a task for asynchronous execution at given point of time.">schedule_at()</a>, but the deadline is "as soon as possible". </p>

</div>
</div>
<a id="af38e6e225ed061079c8e6301b42226fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38e6e225ed061079c8e6301b42226fe">&#9670;&nbsp;</a></span>schedule_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void roc::ctl::ControlTaskQueue::schedule_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroc_1_1ctl_1_1ControlTask.html">ControlTask</a> &amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceroc_1_1core.html#ae97845bc2af55cb259b19da6a128d409">core::nanoseconds_t</a>&#160;</td>
          <td class="paramname"><em>deadline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classroc_1_1ctl_1_1IControlTaskExecutor.html">IControlTaskExecutor</a> &amp;&#160;</td>
          <td class="paramname"><em>executor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classroc_1_1ctl_1_1IControlTaskCompleter.html">IControlTaskCompleter</a> *&#160;</td>
          <td class="paramname"><em>completer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue a task for asynchronous execution at given point of time. </p>
<ul>
<li>If the task is already completed, it's scheduled with given deadline.</li>
<li>If the task is sleeping and waiting for deadline, it's deadline is updated.</li>
<li>If the task is in processing, completion or cancellation phase, it's scheduled to be executed again after completion or cancellation finishes.</li>
<li>If the task is paused, re-scheduling is postponed until task resumes.</li>
</ul>
<p><code>deadline</code> should be in the same domain as <a class="el" href="namespaceroc_1_1core.html#a8a16289f60e32e75ea9707b40415b16e" title="Get current timestamp in nanoseconds.">core::timestamp()</a>. It can't be negative. Zero deadline means "execute as soon as possible".</p>
<p>The <code>executor</code> is used to invoke the task function. It allows to implement tasks in different classes. If a class T wants to implement tasks, it should inherit ControlTaskExecutor&lt;T&gt;.</p>
<p>If <code>completer</code> is present, the task should not be destroyed until completer is invoked. The completer is invoked on event loop thread after once and only once, after the task completes or is cancelled. Completer should never block.</p>
<p>The event loop thread assumes that the task may be destroyed right after it is completed and it's completer is called (if it's present), and don't touch task after this, unless the user explicitly reschedules the task. </p>

</div>
</div>
<a id="afd3437b39e778dfd39743b2c3b26d37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3437b39e778dfd39743b2c3b26d37a">&#9670;&nbsp;</a></span>stop_and_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void roc::ctl::ControlTaskQueue::stop_and_wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop thread and wait until it terminates. </p>
<p>All tasks should be completed before calling <a class="el" href="classroc_1_1ctl_1_1ControlTaskQueue.html#afd3437b39e778dfd39743b2c3b26d37a" title="Stop thread and wait until it terminates.">stop_and_wait()</a>. <a class="el" href="classroc_1_1ctl_1_1ControlTaskQueue.html#afd3437b39e778dfd39743b2c3b26d37a" title="Stop thread and wait until it terminates.">stop_and_wait()</a> should be called before calling destructor. </p>

</div>
</div>
<a id="a238b7163cbfd452f157f96180492196b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238b7163cbfd452f157f96180492196b">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void roc::ctl::ControlTaskQueue::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroc_1_1ctl_1_1ControlTask.html">ControlTask</a> &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the task is completed. </p>
<p>Blocks until the task is completed or cancelled. Does NOT wait until the task completer is called.</p>
<p>Can not be called concurrently for the same task (will cause crash). Can not be called from the task completion handler (will cause deadlock).</p>
<p>If this method is called, the task should not be destroyed until this method returns (as well as until the completer is invoked, if it's present). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>roc_ctl/<a class="el" href="control__task__queue_8h_source.html">control_task_queue.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceroc.html">roc</a></li><li class="navelem"><a class="el" href="namespaceroc_1_1ctl.html">ctl</a></li><li class="navelem"><a class="el" href="classroc_1_1ctl_1_1ControlTaskQueue.html">ControlTaskQueue</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
